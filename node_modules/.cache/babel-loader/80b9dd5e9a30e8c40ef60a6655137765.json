{"ast":null,"code":"import _objectSpread from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar $5b160d28a433310d$export$c17fa47878dc55b6 = /*#__PURE__*/function () {\n  function $5b160d28a433310d$export$c17fa47878dc55b6(messages) {\n    var defaultLocale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';\n\n    _classCallCheck(this, $5b160d28a433310d$export$c17fa47878dc55b6);\n\n    // Clone messages so we don't modify the original object.\n    this.strings = _objectSpread({}, messages);\n    this.defaultLocale = defaultLocale;\n  }\n\n  _createClass($5b160d28a433310d$export$c17fa47878dc55b6, [{\n    key: \"getStringForLocale\",\n    value:\n    /** Returns a localized string for the given key and locale. */\n    function getStringForLocale(key, locale) {\n      var strings = this.strings[locale];\n\n      if (!strings) {\n        strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);\n        this.strings[locale] = strings;\n      }\n\n      var string = strings[key];\n      if (!string) throw new Error(\"Could not find intl message \".concat(key, \" in \").concat(locale, \" locale\"));\n      return string;\n    }\n  }]);\n\n  return $5b160d28a433310d$export$c17fa47878dc55b6;\n}();\n\nfunction $5b160d28a433310d$var$getStringsForLocale(locale, strings) {\n  var defaultLocale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'en-US';\n  // If there is an exact match, use it.\n  if (strings[locale]) return strings[locale]; // Attempt to find the closest match by language.\n  // For example, if the locale is fr-CA (French Canadian), but there is only\n  // an fr-FR (France) set of strings, use that.\n  // This could be replaced with Intl.LocaleMatcher once it is supported.\n  // https://github.com/tc39/proposal-intl-localematcher\n\n  var language = $5b160d28a433310d$var$getLanguage(locale);\n  if (strings[language]) return strings[language];\n\n  for (var key in strings) {\n    if (key.startsWith(language + '-')) return strings[key];\n  } // Nothing close, use english.\n\n\n  return strings[defaultLocale];\n}\n\nfunction $5b160d28a433310d$var$getLanguage(locale) {\n  // @ts-ignore\n  if (Intl.Locale) // @ts-ignore\n    return new Intl.Locale(locale).language;\n  return locale.split('-')[0];\n}\n\nvar $6db58dc88e78b024$var$pluralRulesCache = new Map();\nvar $6db58dc88e78b024$var$numberFormatCache = new Map();\n\nvar $6db58dc88e78b024$export$2f817fcdc4b89ae0 = /*#__PURE__*/function () {\n  function $6db58dc88e78b024$export$2f817fcdc4b89ae0(locale, strings) {\n    _classCallCheck(this, $6db58dc88e78b024$export$2f817fcdc4b89ae0);\n\n    this.locale = locale;\n    this.strings = strings;\n  }\n\n  _createClass($6db58dc88e78b024$export$2f817fcdc4b89ae0, [{\n    key: \"format\",\n    value:\n    /** Formats a localized string for the given key with the provided variables. */\n    function format(key, variables) {\n      var message = this.strings.getStringForLocale(key, this.locale);\n      return typeof message === 'function' ? message(variables, this) : message;\n    }\n  }, {\n    key: \"plural\",\n    value: function plural(count, options) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'cardinal';\n      var opt = options['=' + count];\n      if (opt) return typeof opt === 'function' ? opt() : opt;\n      var key = this.locale + ':' + type;\n      var pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);\n\n      if (!pluralRules) {\n        pluralRules = new Intl.PluralRules(this.locale, {\n          type: type\n        });\n        $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);\n      }\n\n      var selected = pluralRules.select(count);\n      opt = options[selected] || options.other;\n      return typeof opt === 'function' ? opt() : opt;\n    }\n  }, {\n    key: \"number\",\n    value: function number(value) {\n      var numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);\n\n      if (!numberFormat) {\n        numberFormat = new Intl.NumberFormat(this.locale);\n        $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);\n      }\n\n      return numberFormat.format(value);\n    }\n  }, {\n    key: \"select\",\n    value: function select(options, value) {\n      var opt = options[value] || options.other;\n      return typeof opt === 'function' ? opt() : opt;\n    }\n  }]);\n\n  return $6db58dc88e78b024$export$2f817fcdc4b89ae0;\n}();\n\nexport { $5b160d28a433310d$export$c17fa47878dc55b6 as LocalizedStringDictionary, $6db58dc88e78b024$export$2f817fcdc4b89ae0 as LocalizedStringFormatter };","map":{"version":3,"mappings":"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","names":["$5b160d28a433310d$export$c17fa47878dc55b6","messages","defaultLocale","strings","key","locale","$5b160d28a433310d$var$getStringsForLocale","string","Error","language","$5b160d28a433310d$var$getLanguage","startsWith","Intl","Locale","split","$6db58dc88e78b024$var$pluralRulesCache","Map","$6db58dc88e78b024$var$numberFormatCache","$6db58dc88e78b024$export$2f817fcdc4b89ae0","variables","message","getStringForLocale","count","options","type","opt","pluralRules","get","PluralRules","set","selected","select","other","value","numberFormat","NumberFormat","format"],"sources":["/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@internationalized/string/dist/packages/@internationalized/string/src/LocalizedStringDictionary.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@internationalized/string/dist/packages/@internationalized/string/src/LocalizedStringFormatter.ts"],"sourcesContent":["/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {LocalizedString} from './LocalizedStringFormatter';\n\nexport type LocalizedStrings<K extends string, T extends LocalizedString> = {\n  [lang: string]: Record<K, T>\n};\n\n/**\n * Stores a mapping of localized strings. Can be used to find the\n * closest available string for a given locale.\n */\nexport class LocalizedStringDictionary<K extends string = string, T extends LocalizedString = string> {\n  private strings: LocalizedStrings<K, T>;\n  private defaultLocale: string;\n\n  constructor(messages: LocalizedStrings<K, T>, defaultLocale: string = 'en-US') {\n    // Clone messages so we don't modify the original object.\n    this.strings = {...messages};\n    this.defaultLocale = defaultLocale;\n  }\n\n  /** Returns a localized string for the given key and locale. */\n  getStringForLocale(key: K, locale: string): T {\n    let strings = this.strings[locale];\n    if (!strings) {\n      strings = getStringsForLocale(locale, this.strings, this.defaultLocale);\n      this.strings[locale] = strings;\n    }\n\n    let string = strings[key];\n    if (!string) {\n      throw new Error(`Could not find intl message ${key} in ${locale} locale`);\n    }\n\n    return string;\n  }\n}\n\nfunction getStringsForLocale<K extends string, T extends LocalizedString>(locale: string, strings: LocalizedStrings<K, T>, defaultLocale = 'en-US') {\n  // If there is an exact match, use it.\n  if (strings[locale]) {\n    return strings[locale];\n  }\n\n  // Attempt to find the closest match by language.\n  // For example, if the locale is fr-CA (French Canadian), but there is only\n  // an fr-FR (France) set of strings, use that.\n  // This could be replaced with Intl.LocaleMatcher once it is supported.\n  // https://github.com/tc39/proposal-intl-localematcher\n  let language = getLanguage(locale);\n  if (strings[language]) {\n    return strings[language];\n  }\n\n  for (let key in strings) {\n    if (key.startsWith(language + '-')) {\n      return strings[key];\n    }\n  }\n\n  // Nothing close, use english.\n  return strings[defaultLocale];\n}\n\nfunction getLanguage(locale: string) {\n  // @ts-ignore\n  if (Intl.Locale) {\n    // @ts-ignore\n    return new Intl.Locale(locale).language;\n  }\n\n  return locale.split('-')[0];\n}\n","/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {LocalizedStringDictionary} from './LocalizedStringDictionary';\n\nexport type Variables = Record<string, string | number | boolean> | undefined;\nexport type LocalizedString = string | ((args: Variables, formatter?: LocalizedStringFormatter<any, any>) => string);\ntype InternalString = string | (() => string);\n\nconst pluralRulesCache = new Map<string, Intl.PluralRules>();\nconst numberFormatCache = new Map<string, Intl.NumberFormat>();\n\n/**\n * Formats localized strings from a LocalizedStringDictionary. Supports interpolating variables,\n * selecting the correct pluralization, and formatting numbers for the locale.\n */\nexport class LocalizedStringFormatter<K extends string = string, T extends LocalizedString = string> {\n  private locale: string;\n  private strings: LocalizedStringDictionary<K, T>;\n\n  constructor(locale: string, strings: LocalizedStringDictionary<K, T>) {\n    this.locale = locale;\n    this.strings = strings;\n  }\n\n  /** Formats a localized string for the given key with the provided variables. */\n  format(key: K, variables?: Variables): string {\n    let message = this.strings.getStringForLocale(key, this.locale);\n    return typeof message === 'function' ? message(variables, this) : message;\n  }\n\n  protected plural(count: number, options: Record<string, InternalString>, type: Intl.PluralRuleType = 'cardinal') {\n    let opt = options['=' + count];\n    if (opt) {\n      return typeof opt === 'function' ? opt() : opt;\n    }\n\n    let key = this.locale + ':' + type;\n    let pluralRules = pluralRulesCache.get(key);\n    if (!pluralRules) {\n      pluralRules = new Intl.PluralRules(this.locale, {type});\n      pluralRulesCache.set(key, pluralRules);\n    }\n\n    let selected = pluralRules.select(count);\n    opt = options[selected] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n\n  protected number(value: number) {\n    let numberFormat = numberFormatCache.get(this.locale);\n    if (!numberFormat) {\n      numberFormat = new Intl.NumberFormat(this.locale);\n      numberFormatCache.set(this.locale, numberFormat);\n    }\n    return numberFormat.format(value);\n  }\n\n  protected select(options: Record<string, InternalString>, value: string) {\n    let opt = options[value] || options.other;\n    return typeof opt === 'function' ? opt() : opt;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}
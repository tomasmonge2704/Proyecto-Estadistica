{"ast":null,"code":"import _slicedToArray from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _createForOfIteratorHelper from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark($fc36f9a046a9ce79$export$cfc14088dfefce5f);\n\nimport { useState as $8D3nr$useState, useMemo as $8D3nr$useMemo, useEffect as $8D3nr$useEffect, useCallback as $8D3nr$useCallback } from \"react\";\nimport { useLayoutEffect as $8D3nr$useLayoutEffect } from \"@react-aria/utils\";\n\nvar $c74cda7d31af1253$export$c84671f46d6a1ca = /*#__PURE__*/function () {\n  function $c74cda7d31af1253$export$c84671f46d6a1ca() {\n    _classCallCheck(this, $c74cda7d31af1253$export$c84671f46d6a1ca);\n  }\n\n  _createClass($c74cda7d31af1253$export$c84671f46d6a1ca, [{\n    key: \"shouldInvalidate\",\n    value:\n    /**\n    * Returns whether the layout should invalidate in response to\n    * visible rectangle changes. By default, it only invalidates\n    * when the collection view's size changes. Return true always\n    * to make the layout invalidate while scrolling (e.g. sticky headers).\n    */\n    function shouldInvalidate(newRect, oldRect) {\n      // By default, invalidate when the size changes\n      return newRect.width !== oldRect.width || newRect.height !== oldRect.height;\n    }\n    /**\n    * This method allows the layout to perform any pre-computation\n    * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n    * Called by the collection view before {@link getVisibleLayoutInfos}\n    * or {@link getLayoutInfo} are called.\n    */\n\n  }, {\n    key: \"validate\",\n    value: function validate(invalidationContext) {}\n    /**\n    * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n    * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n    * @param point The point at which the drag occurred.\n    */\n    // getDragTarget(point: Point): DragTarget | null {\n    //   let target = this.virtualizer.keyAtPoint(point);\n    //   if (!target) {\n    //     return null;\n    //   }\n    //   return {\n    //     type: 'item',\n    //     key: target\n    //   };\n    // }\n\n    /**\n    * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n    * to reject the drop. The dropped items will be inserted before the resulting target.\n    * @param point The point at which the drop occurred.\n    */\n    // getDropTarget(point: Point): DropTarget | null {\n    //   return null;\n    // }\n\n    /**\n    * Returns the starting attributes for an animated insertion.\n    * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n    * The default implementation just returns its input.\n    *\n    * @param layoutInfo The proposed LayoutInfo for this view.\n    */\n\n  }, {\n    key: \"getInitialLayoutInfo\",\n    value: function getInitialLayoutInfo(layoutInfo) {\n      return layoutInfo;\n    }\n    /**\n    * Returns the ending attributes for an animated removal.\n    * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n    * to the one returned by this method. The default implementation returns its input.\n    *\n    * @param layoutInfo The original LayoutInfo for this view.\n    */\n\n  }, {\n    key: \"getFinalLayoutInfo\",\n    value: function getFinalLayoutInfo(layoutInfo) {\n      return layoutInfo;\n    }\n  }]);\n\n  return $c74cda7d31af1253$export$c84671f46d6a1ca;\n}();\n\nvar $d7fd61009c21d0bb$export$7e0eeb9da702a085 = /*#__PURE__*/function () {\n  /**\n  * @param type A string representing the view type. Should be `'item'` for item views.\n                          Other types are used by supplementary views.\n  * @param key The unique key for this view.\n  * @param rect The rectangle describing the size and position of this view.\n  */\n  function $d7fd61009c21d0bb$export$7e0eeb9da702a085(type, key, rect) {\n    _classCallCheck(this, $d7fd61009c21d0bb$export$7e0eeb9da702a085);\n\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  _createClass($d7fd61009c21d0bb$export$7e0eeb9da702a085, [{\n    key: \"copy\",\n    value:\n    /**\n    * Returns a copy of the LayoutInfo.\n    */\n    function copy() {\n      var res = new $d7fd61009c21d0bb$export$7e0eeb9da702a085(this.type, this.key, this.rect.copy());\n      res.estimatedSize = this.estimatedSize;\n      res.opacity = this.opacity;\n      res.transform = this.transform;\n      res.parentKey = this.parentKey;\n      res.isSticky = this.isSticky;\n      res.zIndex = this.zIndex;\n      res.allowOverflow = this.allowOverflow;\n      return res;\n    }\n  }]);\n\n  return $d7fd61009c21d0bb$export$7e0eeb9da702a085;\n}();\n\nvar $3041db3296945e6e$export$baf26146a414f24a = /*#__PURE__*/function () {\n  function $3041db3296945e6e$export$baf26146a414f24a() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, $3041db3296945e6e$export$baf26146a414f24a);\n\n    this.x = x;\n    this.y = y;\n  }\n\n  _createClass($3041db3296945e6e$export$baf26146a414f24a, [{\n    key: \"copy\",\n    value:\n    /**\n    * Returns a copy of this point.\n    */\n    function copy() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n    * Checks if two points are equal.\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(point) {\n      return this.x === point.x && this.y === point.y;\n    }\n    /**\n    * Returns true if this point is the origin.\n    */\n\n  }, {\n    key: \"isOrigin\",\n    value: function isOrigin() {\n      return this.x === 0 && this.y === 0;\n    }\n  }]);\n\n  return $3041db3296945e6e$export$baf26146a414f24a;\n}();\n\nvar $60423f92c7f9ad87$export$c79fc6492f3af13d = /*#__PURE__*/function () {\n  function $60423f92c7f9ad87$export$c79fc6492f3af13d() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  _createClass($60423f92c7f9ad87$export$c79fc6492f3af13d, [{\n    key: \"maxX\",\n    get:\n    /**\n    * The maximum x-coordinate in the rectangle.\n    */\n    function get() {\n      return this.x + this.width;\n    }\n    /**\n    * The maximum y-coordinate in the rectangle.\n    */\n\n  }, {\n    key: \"maxY\",\n    get: function get() {\n      return this.y + this.height;\n    }\n    /**\n    * The area of the rectangle.\n    */\n\n  }, {\n    key: \"area\",\n    get: function get() {\n      return this.width * this.height;\n    }\n    /**\n    * The top left corner of the rectangle.\n    */\n\n  }, {\n    key: \"topLeft\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.y);\n    }\n    /**\n    * The top right corner of the rectangle.\n    */\n\n  }, {\n    key: \"topRight\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.y);\n    }\n    /**\n    * The bottom left corner of the rectangle.\n    */\n\n  }, {\n    key: \"bottomLeft\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.x, this.maxY);\n    }\n    /**\n    * The bottom right corner of the rectangle.\n    */\n\n  }, {\n    key: \"bottomRight\",\n    get: function get() {\n      return new $3041db3296945e6e$export$baf26146a414f24a(this.maxX, this.maxY);\n    }\n    /**\n    * Returns whether this rectangle intersects another rectangle.\n    * @param rect - The rectangle to check.\n    */\n\n  }, {\n    key: \"intersects\",\n    value: function intersects(rect) {\n      return this.x <= rect.x + rect.width && rect.x <= this.x + this.width && this.y <= rect.y + rect.height && rect.y <= this.y + this.height;\n    }\n    /**\n    * Returns whether this rectangle fully contains another rectangle.\n    * @param rect - The rectangle to check.\n    */\n\n  }, {\n    key: \"containsRect\",\n    value: function containsRect(rect) {\n      return this.x <= rect.x && this.y <= rect.y && this.maxX >= rect.maxX && this.maxY >= rect.maxY;\n    }\n    /**\n    * Returns whether the rectangle contains the given point.\n    * @param point - The point to check.\n    */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(point) {\n      return this.x <= point.x && this.y <= point.y && this.maxX >= point.x && this.maxY >= point.y;\n    }\n    /**\n    * Returns the first corner of this rectangle (from top to bottom, left to right)\n    * that is contained in the given rectangle, or null of the rectangles do not intersect.\n    * @param rect - The rectangle to check.\n    */\n\n  }, {\n    key: \"getCornerInRect\",\n    value: function getCornerInRect(rect) {\n      for (var _i = 0, _arr = ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']; _i < _arr.length; _i++) {\n        var key = _arr[_i];\n        if (rect.containsPoint(this[key])) return key;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rect) {\n      return rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n  }, {\n    key: \"pointEquals\",\n    value: function pointEquals(point) {\n      return this.x === point.x && this.y === point.y;\n    }\n  }, {\n    key: \"sizeEquals\",\n    value: function sizeEquals(size) {\n      return this.width === size.width && this.height === size.height;\n    }\n    /**\n    * Returns a copy of this rectangle.\n    */\n\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(this.x, this.y, this.width, this.height);\n    }\n  }]);\n\n  return $60423f92c7f9ad87$export$c79fc6492f3af13d;\n}();\n\nvar $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec = /*#__PURE__*/function () {\n  function $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec() {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n\n    this.width = width;\n    this.height = height;\n  }\n\n  _createClass($ee1bfa90a957fb8a$export$cb6da89c6af1a8ec, [{\n    key: \"copy\",\n    value:\n    /**\n    * Returns a copy of this size.\n    */\n    function copy() {\n      return new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec(this.width, this.height);\n    }\n    /**\n    * Returns whether this size is equal to another one.\n    */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.width === other.width && this.height === other.height;\n    }\n  }]);\n\n  return $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec;\n}();\n\nvar $ad1d98aa8f0c31b4$var$KEY = 0;\n\nvar $ad1d98aa8f0c31b4$export$1a5223887c560441 = /*#__PURE__*/function () {\n  function $ad1d98aa8f0c31b4$export$1a5223887c560441(virtualizer) {\n    _classCallCheck(this, $ad1d98aa8f0c31b4$export$1a5223887c560441);\n\n    this.virtualizer = virtualizer;\n    this.key = ++$ad1d98aa8f0c31b4$var$KEY;\n  }\n\n  _createClass($ad1d98aa8f0c31b4$export$1a5223887c560441, [{\n    key: \"prepareForReuse\",\n    value:\n    /**\n    * Prepares the view for reuse. Called just before the view is removed from the DOM.\n    */\n    function prepareForReuse() {\n      this.content = null;\n      this.rendered = null;\n      this.layoutInfo = null;\n    }\n  }]);\n\n  return $ad1d98aa8f0c31b4$export$1a5223887c560441;\n}(); // use high res timer if available\n\n\nvar $3eb131dcf37ad5f8$var$perf = typeof window !== 'undefined' ? window.performance : null; // @ts-ignore\n\nvar $3eb131dcf37ad5f8$var$perfNow = $3eb131dcf37ad5f8$var$perf && ($3eb131dcf37ad5f8$var$perf.now || $3eb131dcf37ad5f8$var$perf.webkitNow || $3eb131dcf37ad5f8$var$perf.msNow || $3eb131dcf37ad5f8$var$perf.mozNow);\nvar $3eb131dcf37ad5f8$var$getTime = $3eb131dcf37ad5f8$var$perfNow ? $3eb131dcf37ad5f8$var$perfNow.bind($3eb131dcf37ad5f8$var$perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\nvar $3eb131dcf37ad5f8$var$fixTs;\n\nfunction $3eb131dcf37ad5f8$export$dc0b63720788090c(begin, end, duration, ease, fn) {\n  var canceled = false;\n  var raf_id;\n  var promise = new Promise(function (resolve) {\n    var start = $3eb131dcf37ad5f8$var$getTime();\n    var diffX = end.x - begin.x;\n    var diffY = end.y - begin.y;\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if ($3eb131dcf37ad5f8$var$fixTs == null) $3eb131dcf37ad5f8$var$fixTs = t > 1000000000000 !== $3eb131dcf37ad5f8$var$getTime() > 1000000000000;\n      if ($3eb131dcf37ad5f8$var$fixTs) t = $3eb131dcf37ad5f8$var$getTime(); // check if we're done\n\n      var delta = t - start;\n\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        var proceed = fn(new $3041db3296945e6e$export$baf26146a414f24a(begin.x + diffX * ease(delta / duration), begin.y + diffY * ease(delta / duration)));\n        if (proceed !== false && !canceled) raf_id = requestAnimationFrame(run);\n      }\n    });\n  });\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\nfunction $3eb131dcf37ad5f8$export$77860c106b4a6a2e(t) {\n  return t;\n}\n\nfunction $3eb131dcf37ad5f8$export$57636bb43b1ccbb0(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n\nfunction $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b) {\n  var res = new Set();\n\n  var _iterator = _createForOfIteratorHelper(a.keys()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var key = _step.value;\n      if (!b.has(key)) res.add(key);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$acaf96a27438246b(a, b) {\n  var toRemove = $fc36f9a046a9ce79$export$37a26b283fd7740e(a, b);\n  var toAdd = $fc36f9a046a9ce79$export$37a26b283fd7740e(b, a);\n  var toUpdate = new Set();\n\n  var _iterator2 = _createForOfIteratorHelper(a.keys()),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var key = _step2.value;\n      if (b.has(key)) toUpdate.add(key);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return {\n    toRemove: toRemove,\n    toAdd: toAdd,\n    toUpdate: toUpdate\n  };\n}\n\nfunction $fc36f9a046a9ce79$export$cfc14088dfefce5f() {\n  var _len,\n      iterators,\n      _key,\n      _i2,\n      _iterators,\n      iterator,\n      _args = arguments;\n\n  return _regeneratorRuntime().wrap(function $fc36f9a046a9ce79$export$cfc14088dfefce5f$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          for (_len = _args.length, iterators = new Array(_len), _key = 0; _key < _len; _key++) {\n            iterators[_key] = _args[_key];\n          }\n\n          _i2 = 0, _iterators = iterators;\n\n        case 2:\n          if (!(_i2 < _iterators.length)) {\n            _context.next = 8;\n            break;\n          }\n\n          iterator = _iterators[_i2];\n          return _context.delegateYield(iterator, \"t0\", 5);\n\n        case 5:\n          _i2++;\n          _context.next = 2;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n\nfunction $fc36f9a046a9ce79$export$6897c284b6f9f4dc(object) {\n  var res = {};\n\n  for (var key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\nfunction $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(a, b) {\n  if (a === b) return true;\n  if (a.size !== b.size) return false;\n\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var key = _step3.value;\n      if (!b.has(key)) return false;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return true;\n}\n\nvar $364191b3decf3697$var$RollingAverage = /*#__PURE__*/function () {\n  function $364191b3decf3697$var$RollingAverage() {\n    _classCallCheck(this, $364191b3decf3697$var$RollingAverage);\n\n    this.count = 0;\n    this.value = 0;\n  }\n\n  _createClass($364191b3decf3697$var$RollingAverage, [{\n    key: \"addSample\",\n    value: function addSample(sample) {\n      this.count++;\n      this.value += (sample - this.value) / this.count;\n    }\n  }]);\n\n  return $364191b3decf3697$var$RollingAverage;\n}();\n\nvar $364191b3decf3697$export$4455ee6afb38dcbb = /*#__PURE__*/function () {\n  function $364191b3decf3697$export$4455ee6afb38dcbb() {\n    _classCallCheck(this, $364191b3decf3697$export$4455ee6afb38dcbb);\n\n    this.startTime = 0;\n    this.averagePerf = new $364191b3decf3697$var$RollingAverage();\n    this.averageTime = new $364191b3decf3697$var$RollingAverage();\n    this.velocity = new $3041db3296945e6e$export$baf26146a414f24a(5, 5);\n    this.overscanX = new $364191b3decf3697$var$RollingAverage();\n    this.overscanY = new $364191b3decf3697$var$RollingAverage();\n    this.visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n  }\n\n  _createClass($364191b3decf3697$export$4455ee6afb38dcbb, [{\n    key: \"setVisibleRect\",\n    value: function setVisibleRect(rect) {\n      var time = performance.now() - this.startTime;\n\n      if (time < 500) {\n        this.averageTime.addSample(time);\n        if (rect.x !== this.visibleRect.x && time > 0) this.velocity.x = (rect.x - this.visibleRect.x) / time;\n        if (rect.y !== this.visibleRect.y && time > 0) this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n\n      this.startTime = performance.now();\n      this.visibleRect = rect;\n    }\n  }, {\n    key: \"collectMetrics\",\n    value: function collectMetrics() {\n      var time = performance.now() - this.startTime;\n      if (time < 500) this.averagePerf.addSample(time);\n\n      if (this.visibleRect.height > 0) {\n        var o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));\n        this.overscanY.addSample(o);\n      }\n\n      if (this.visibleRect.width > 0) {\n        var _o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));\n\n        this.overscanX.addSample(_o);\n      }\n    }\n  }, {\n    key: \"getOverscannedRect\",\n    value: function getOverscannedRect() {\n      var overscanned = this.visibleRect.copy();\n      var overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n\n      if (this.velocity.y > 0) {\n        overscanned.y -= overscanY * 0.2;\n        overscanned.height += overscanY + overscanY * 0.2;\n      } else {\n        overscanned.y -= overscanY;\n        overscanned.height += overscanY + overscanY * 0.2;\n      }\n\n      var overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n\n      if (this.velocity.x > 0) {\n        overscanned.x -= overscanX * 0.2;\n        overscanned.width += overscanX + overscanX * 0.2;\n      } else {\n        overscanned.x -= overscanX;\n        overscanned.width += overscanX + overscanX * 0.2;\n      }\n\n      return overscanned;\n    }\n  }]);\n\n  return $364191b3decf3697$export$4455ee6afb38dcbb;\n}();\n\nvar $8e135e531d8dcb66$export$febc5573c75cefb0 = /*#__PURE__*/_createClass(function $8e135e531d8dcb66$export$febc5573c75cefb0() {\n  _classCallCheck(this, $8e135e531d8dcb66$export$febc5573c75cefb0);\n\n  this.level = 0;\n  this.actions = [];\n  this.animated = true;\n  this.initialMap = new Map();\n  this.finalMap = new Map();\n  this.initialLayoutInfo = new Map();\n  this.finalLayoutInfo = new Map();\n  this.removed = new Map();\n  this.toRemove = new Map();\n});\n\nvar $38b9490c1cca8fc4$export$89be5a243e59c4b2 = /*#__PURE__*/function () {\n  function $38b9490c1cca8fc4$export$89be5a243e59c4b2() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, $38b9490c1cca8fc4$export$89be5a243e59c4b2);\n\n    this._contentSize = new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec();\n    this._visibleRect = new $60423f92c7f9ad87$export$c79fc6492f3af13d();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new $364191b3decf3697$export$4455ee6afb38dcbb();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    var _transitionDuration; // Set options from passed object if given\n\n\n    this.transitionDuration = (_transitionDuration = options.transitionDuration) !== null && _transitionDuration !== void 0 ? _transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n\n    for (var _i3 = 0, _arr2 = ['delegate', 'size', 'layout', 'collection']; _i3 < _arr2.length; _i3++) {\n      var key = _arr2[_i3];\n      if (options[key]) this[key] = options[key];\n    }\n  }\n\n  _createClass($38b9490c1cca8fc4$export$89be5a243e59c4b2, [{\n    key: \"_setContentSize\",\n    value: function _setContentSize(size) {\n      this._contentSize = size;\n      this.delegate.setContentSize(size);\n    }\n  }, {\n    key: \"_setContentOffset\",\n    value: function _setContentOffset(offset) {\n      var rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n      this.delegate.setVisibleRect(rect);\n    }\n    /**\n    * Get the size of the scrollable content.\n    */\n\n  }, {\n    key: \"contentSize\",\n    get: function get() {\n      return this._contentSize;\n    }\n    /**\n    * Get the collection view's currently visible rectangle.\n    */\n\n  }, {\n    key: \"visibleRect\",\n    get: function get() {\n      return this._visibleRect;\n    }\n    /**\n    * Set the collection view's currently visible rectangle.\n    */\n    ,\n    set: function set(rect) {\n      this._setVisibleRect(rect);\n    }\n  }, {\n    key: \"_setVisibleRect\",\n    value: function _setVisibleRect(rect) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var current = this._visibleRect; // Ignore if the rects are equal\n\n      if (rect.equals(current)) return;\n      if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n      this._resetAnimatedContentOffset();\n\n      this._visibleRect = rect;\n      if (shouldInvalidate) this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });else this.updateSubviews(forceUpdate);\n    }\n  }, {\n    key: \"collection\",\n    get: function get() {\n      return this._collection;\n    },\n    set: function set(data) {\n      this._setData(data);\n    }\n  }, {\n    key: \"_setData\",\n    value: function _setData(data) {\n      var _this = this;\n\n      if (data === this._collection) return;\n      if (this._collection) this._runTransaction(function () {\n        _this._collection = data;\n      }, this.transitionDuration > 0);else {\n        this._collection = data;\n        this.reloadData();\n      }\n    }\n    /**\n    * Reloads the data from the data source and relayouts the collection view.\n    * Does not animate any changes. Equivalent to re-assigning the same data source\n    * to the collection view.\n    */\n\n  }, {\n    key: \"reloadData\",\n    value: function reloadData() {\n      this.relayout({\n        contentChanged: true\n      });\n    }\n    /**\n    * Returns the item with the given key.\n    */\n\n  }, {\n    key: \"getItem\",\n    value: function getItem(key) {\n      return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n\n  }, {\n    key: \"persistedKeys\",\n    get: function get() {\n      return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n    ,\n    set: function set(persistedKeys) {\n      if (!$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64(persistedKeys, this._persistedKeys)) {\n        this._persistedKeys = persistedKeys;\n        this.updateSubviews();\n      }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */\n\n  }, {\n    key: \"isPersistedKey\",\n    value: function isPersistedKey(key) {\n      // Quick check if the key is directly in the set of persisted keys.\n      if (this._persistedKeys.has(key)) return true; // If not, check if the key is an ancestor of any of the persisted keys.\n\n      var _iterator4 = _createForOfIteratorHelper(this._persistedKeys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var k = _step4.value;\n\n          while (k != null) {\n            var layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return false;\n    }\n    /**\n    * Get the collection view's layout.\n    */\n\n  }, {\n    key: \"layout\",\n    get: function get() {\n      return this._layout;\n    }\n    /**\n    * Set the collection view's layout.\n    */\n    ,\n    set: function set(layout) {\n      this.setLayout(layout);\n    }\n    /**\n    * Sets the collection view's layout, optionally with an animated transition\n    * from the current layout to the new layout.\n    * @param layout The layout to switch to.\n    * @param animated Whether to animate the layout change.\n    */\n\n  }, {\n    key: \"setLayout\",\n    value: function setLayout(layout) {\n      var _this2 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (layout === this._layout) return;\n\n      var applyLayout = function applyLayout() {\n        if (_this2._layout) // @ts-ignore\n          _this2._layout.virtualizer = null;\n        layout.virtualizer = _this2;\n        _this2._layout = layout;\n      };\n\n      if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);else {\n        applyLayout();\n        this.relayout();\n      }\n    }\n  }, {\n    key: \"_getReuseType\",\n    value: function _getReuseType(layoutInfo, content) {\n      if (layoutInfo.type === 'item' && content) {\n        var type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n        var reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n        return {\n          type: type,\n          reuseType: reuseType\n        };\n      }\n\n      return {\n        type: layoutInfo.type,\n        reuseType: layoutInfo.type\n      };\n    }\n  }, {\n    key: \"getReusableView\",\n    value: function getReusableView(layoutInfo) {\n      var content = this.getItem(layoutInfo.key);\n\n      var _this$_getReuseType = this._getReuseType(layoutInfo, content),\n          reuseType = _this$_getReuseType.reuseType;\n\n      if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n      var reusable = this._reusableViews[reuseType];\n      var view = reusable.length > 0 ? reusable.pop() : new $ad1d98aa8f0c31b4$export$1a5223887c560441(this);\n      view.viewType = reuseType;\n\n      if (!this._animatedContentOffset.isOrigin()) {\n        layoutInfo = layoutInfo.copy();\n        layoutInfo.rect.x += this._animatedContentOffset.x;\n        layoutInfo.rect.y += this._animatedContentOffset.y;\n      }\n\n      view.layoutInfo = layoutInfo;\n\n      this._renderView(view);\n\n      return view;\n    }\n  }, {\n    key: \"_renderView\",\n    value: function _renderView(reusableView) {\n      var _reusableView$layoutI = reusableView.layoutInfo,\n          type = _reusableView$layoutI.type,\n          key = _reusableView$layoutI.key;\n      reusableView.content = this.getItem(key);\n      reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n  }, {\n    key: \"_renderContent\",\n    value: function _renderContent(type, content) {\n      var cached = this._renderedContent.get(content);\n\n      if (cached != null) return cached;\n      var rendered = this.delegate.renderView(type, content);\n      if (content) this._renderedContent.set(content, rendered);\n      return rendered;\n    }\n    /**\n    * Returns an array of all currently visible views, including both\n    * item views and supplementary views.\n    */\n\n  }, {\n    key: \"visibleViews\",\n    get: function get() {\n      return Array.from(this._visibleViews.values());\n    }\n    /**\n    * Gets the visible view for the given type and key. Returns null if\n    * the view is not currently visible.\n    *\n    * @param key The key of the view to retrieve.\n    */\n\n  }, {\n    key: \"getView\",\n    value: function getView(key) {\n      return this._visibleViews.get(key) || null;\n    }\n    /**\n    * Returns an array of visible views matching the given type.\n    * @param type The view type to find.\n    */\n\n  }, {\n    key: \"getViewsOfType\",\n    value: function getViewsOfType(type) {\n      return this.visibleViews.filter(function (v) {\n        return v.layoutInfo && v.layoutInfo.type === type;\n      });\n    }\n    /**\n    * Returns the key for the given view. Returns null\n    * if the view is not currently visible.\n    */\n\n  }, {\n    key: \"keyForView\",\n    value: function keyForView(view) {\n      if (view && view.layoutInfo) return view.layoutInfo.key;\n      return null;\n    }\n    /**\n    * Returns the key for the item view currently at the given point.\n    */\n\n  }, {\n    key: \"keyAtPoint\",\n    value: function keyAtPoint(point) {\n      var rect = new $60423f92c7f9ad87$export$c79fc6492f3af13d(point.x, point.y, 1, 1);\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect); // Layout may return multiple layout infos in the case of\n      // persisted keys, so find the first one that actually intersects.\n\n      var _iterator5 = _createForOfIteratorHelper(layoutInfos),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var layoutInfo = _step5.value;\n          if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return null;\n    }\n    /**\n    * Cleanup for when the Virtualizer will be unmounted.\n    */\n\n  }, {\n    key: \"willUnmount\",\n    value: function willUnmount() {\n      cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n    * Triggers a layout invalidation, and updates the visible subviews.\n    */\n\n  }, {\n    key: \"relayout\",\n    value: function relayout() {\n      var _this3 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      // Ignore relayouts while animating the scroll position\n      if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') return; // If we already scheduled a relayout, extend the invalidation\n      // context so we coalesce multiple relayouts in the same frame.\n\n      if (this._invalidationContext) {\n        Object.assign(this._invalidationContext, context);\n        return;\n      }\n\n      this._invalidationContext = context;\n      this._relayoutRaf = requestAnimationFrame(function () {\n        _this3._relayoutRaf = null;\n\n        _this3.relayoutNow();\n      });\n    }\n    /**\n    * Performs a relayout immediately. Prefer {@link relayout} over this method\n    * where possible, since it coalesces multiple layout passes in the same tick.\n    */\n\n  }, {\n    key: \"relayoutNow\",\n    value: function relayoutNow() {\n      var _this4 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {};\n\n      // Cancel the scheduled relayout, since we're doing it now.\n      if (this._relayoutRaf) {\n        cancelAnimationFrame(this._relayoutRaf);\n        this._relayoutRaf = null; // Update the provided context with the current invalidationContext since we are cancelling\n        // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n\n        context = _objectSpread(_objectSpread({}, this._invalidationContext), context);\n      } // Reset the invalidation context\n\n\n      this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n      // in the middle of an animated scroll transition.\n\n      if (!this.layout || !this._collection || this._scrollAnimation) return;\n\n      var scrollAnchor = this._getScrollAnchor(); // Trigger the beforeLayout hook, if provided\n\n\n      if (typeof context.beforeLayout === 'function') context.beforeLayout(); // Validate the layout\n\n      this.layout.validate(context);\n\n      this._setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n\n      if (typeof context.afterLayout === 'function') context.afterLayout(); // Adjust scroll position based on scroll anchor, and constrain.\n      // If the content changed, scroll to the top.\n\n      var visibleRect = this.getVisibleRect();\n\n      var restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n      var contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n      var contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n      contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n      contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n      var hasLayoutUpdates = false;\n\n      if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n        // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n        // Save the difference between the current and new content offsets, and apply it to the\n        // individual content items instead. At the end of the animation, we'll reset and set the\n        // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n        // the scroll animation and the content animation.\n        if (context.animated || !this._animatedContentOffset.isOrigin()) {\n          this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n          this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n          hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        } else this._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(contentOffsetX, contentOffsetY));\n      } else hasLayoutUpdates = this.updateSubviews(context.contentChanged); // Apply layout infos, unless this is coming from an animated transaction\n\n\n      if (!(context.transaction && context.animated)) this._applyLayoutInfos(); // Wait for animations, and apply the afterAnimation hook, if provided\n\n      if (context.animated && hasLayoutUpdates) {\n        this._enableTransitions();\n\n        var done = function done() {\n          _this4._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n          if (!_this4._animatedContentOffset.isOrigin()) {\n            // Get the content offset to scroll to, taking _animatedContentOffset into account.\n            var _this4$getVisibleRect = _this4.getVisibleRect(),\n                x = _this4$getVisibleRect.x,\n                y = _this4$getVisibleRect.y;\n\n            _this4._resetAnimatedContentOffset();\n\n            _this4._setContentOffset(new $3041db3296945e6e$export$baf26146a414f24a(x, y));\n          }\n\n          if (typeof context.afterAnimation === 'function') context.afterAnimation();\n        }; // Sometimes the animation takes slightly longer than expected.\n\n\n        setTimeout(done, this.transitionDuration + 100);\n        return;\n      } else if (typeof context.afterAnimation === 'function') context.afterAnimation();\n    }\n    /**\n    * Corrects DOM order of visible views to match item order of collection.\n    */\n\n  }, {\n    key: \"_correctItemOrder\",\n    value: function _correctItemOrder() {\n      // Defer until after scrolling and animated transactions are complete\n      if (this._isScrolling || this._transaction) return;\n\n      var _iterator6 = _createForOfIteratorHelper(this._visibleLayoutInfos.keys()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var key = _step6.value;\n\n          var view = this._visibleViews.get(key);\n\n          this._children.delete(view);\n\n          this._children.add(view);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"_enableTransitions\",\n    value: function _enableTransitions() {\n      this.delegate.beginAnimations();\n    }\n  }, {\n    key: \"_disableTransitions\",\n    value: function _disableTransitions() {\n      this.delegate.endAnimations();\n    }\n  }, {\n    key: \"_getScrollAnchor\",\n    value: function _getScrollAnchor() {\n      if (!this.anchorScrollPosition) return null;\n      var visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n      if (this.delegate.getScrollAnchor) {\n        var key = this.delegate.getScrollAnchor(visibleRect);\n\n        if (key != null) {\n          var layoutInfo = this.layout.getLayoutInfo(key);\n          var corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n          if (corner) {\n            var _key2 = layoutInfo.key;\n            var offset = layoutInfo.rect[corner].y - visibleRect.y;\n            return {\n              key: _key2,\n              layoutInfo: layoutInfo,\n              corner: corner,\n              offset: offset\n            };\n          }\n        }\n      } // No need to anchor the scroll position if it is at the top\n\n\n      if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null; // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n      var cornerAnchor = null;\n\n      var _iterator7 = _createForOfIteratorHelper(this._visibleViews),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              _key3 = _step7$value[0],\n              view = _step7$value[1];\n\n          var _layoutInfo = view.layoutInfo;\n\n          if (_layoutInfo && _layoutInfo.rect.area > 0) {\n            var _corner = _layoutInfo.rect.getCornerInRect(visibleRect);\n\n            if (_corner) {\n              var _offset = _layoutInfo.rect[_corner].y - visibleRect.y;\n\n              if (!cornerAnchor || _offset < cornerAnchor.offset) cornerAnchor = {\n                key: _key3,\n                layoutInfo: _layoutInfo,\n                corner: _corner,\n                offset: _offset\n              };\n            }\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return cornerAnchor;\n    }\n  }, {\n    key: \"_restoreScrollAnchor\",\n    value: function _restoreScrollAnchor(scrollAnchor, context) {\n      var contentOffset = this.getVisibleRect();\n\n      if (scrollAnchor) {\n        var ref;\n        var finalAnchor = ((ref = context.transaction) === null || ref === void 0 ? void 0 : ref.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n        if (finalAnchor) {\n          var adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n          contentOffset.y += adjustment;\n        }\n      }\n\n      return contentOffset;\n    }\n  }, {\n    key: \"getVisibleRect\",\n    value: function getVisibleRect() {\n      var v = this.visibleRect;\n      var x = v.x - this._animatedContentOffset.x;\n      var y = v.y - this._animatedContentOffset.y;\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(x, y, v.width, v.height);\n    }\n  }, {\n    key: \"getVisibleLayoutInfos\",\n    value: function getVisibleLayoutInfos() {\n      var rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n      this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n      return this._visibleLayoutInfos;\n    }\n  }, {\n    key: \"_getLayoutInfoMap\",\n    value: function _getLayoutInfoMap(rect) {\n      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n      var map = new Map();\n\n      var _iterator8 = _createForOfIteratorHelper(layoutInfos),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var layoutInfo = _step8.value;\n          if (copy) layoutInfo = layoutInfo.copy();\n          map.set(layoutInfo.key, layoutInfo);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return map;\n    }\n  }, {\n    key: \"updateSubviews\",\n    value: function updateSubviews() {\n      var _this5 = this;\n\n      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (!this._collection) return;\n      var visibleLayoutInfos = this.getVisibleLayoutInfos();\n      var currentlyVisible = this._visibleViews;\n      var toAdd, toRemove, toUpdate; // If this is a force update, remove and re-add all views.\n      // Otherwise, find and update the diff.\n\n      if (forceUpdate) {\n        toAdd = visibleLayoutInfos;\n        toRemove = currentlyVisible;\n        toUpdate = new Set();\n      } else {\n        var _$fc36f9a046a9ce79$ex = $fc36f9a046a9ce79$export$acaf96a27438246b(currentlyVisible, visibleLayoutInfos);\n\n        toAdd = _$fc36f9a046a9ce79$ex.toAdd;\n        toRemove = _$fc36f9a046a9ce79$ex.toRemove;\n        toUpdate = _$fc36f9a046a9ce79$ex.toUpdate;\n\n        var _iterator9 = _createForOfIteratorHelper(toUpdate),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var key = _step9.value;\n            var view = currentlyVisible.get(key);\n            if (!view || !view.layoutInfo) continue;\n            var item = this.getItem(visibleLayoutInfos.get(key).key);\n            if (view.content === item) toUpdate.delete(key);else {\n              // If the view type changes, delete and recreate the view instead of updating\n              var _this$_getReuseType2 = this._getReuseType(view.layoutInfo, item),\n                  reuseType = _this$_getReuseType2.reuseType;\n\n              if (view.viewType !== reuseType) {\n                toUpdate.delete(key);\n                toAdd.add(key);\n                toRemove.add(key);\n              }\n            }\n          } // We are done if the sets are equal\n\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n          if (this._transaction) this._applyLayoutInfos();\n          return;\n        }\n      } // Track views that should be removed. They are not removed from\n      // the DOM immediately, since we may reuse and need to re-insert\n      // them back into the DOM anyway.\n\n\n      var removed = new Set();\n\n      var _iterator10 = _createForOfIteratorHelper(toRemove.keys()),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _key4 = _step10.value;\n\n          var _view = this._visibleViews.get(_key4);\n\n          if (_view) {\n            removed.add(_view);\n\n            this._visibleViews.delete(_key4); // If we are in the middle of a transaction, wait until the end\n            // of the animations to remove the views from the DOM. Also means\n            // we can't reuse those views immediately.\n\n\n            if (this._transaction) this._transaction.toRemove.set(_key4, _view);else this.reuseView(_view);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      var _iterator11 = _createForOfIteratorHelper(toAdd.keys()),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var key1 = _step11.value;\n          var layoutInfo = visibleLayoutInfos.get(key1);\n\n          var _view2 = void 0; // If we're in a transaction, and a layout change happens\n          // during the animations such that a view that was going\n          // to be removed is now not, we don't create a new view\n          // since the old one is still in the DOM, marked as toRemove.\n\n\n          if (this._transaction) {\n            // if transaction, get initial layout attributes for the animation\n            if (this._transaction.initialLayoutInfo.has(key1)) layoutInfo = this._transaction.initialLayoutInfo.get(key1);\n            _view2 = this._transaction.toRemove.get(key1);\n\n            if (_view2) {\n              this._transaction.toRemove.delete(key1);\n\n              this._applyLayoutInfo(_view2, layoutInfo);\n            }\n          }\n\n          if (!_view2) {\n            // Create or reuse a view for this row\n            _view2 = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n            if (!removed.has(_view2)) this._children.add(_view2);\n          }\n\n          this._visibleViews.set(key1, _view2);\n\n          removed.delete(_view2);\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      var _iterator12 = _createForOfIteratorHelper(toUpdate),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var key2 = _step12.value;\n\n          var _view3 = currentlyVisible.get(key2);\n\n          this._renderedContent.delete(key2);\n\n          this._renderView(_view3);\n        } // Remove the remaining rows to delete from the DOM\n\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      if (!this._transaction) this.removeViews(removed);\n\n      this._correctItemOrder();\n\n      this._flushVisibleViews();\n\n      var hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n\n      if (hasLayoutUpdates) requestAnimationFrame(function () {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (_this5._transaction) requestAnimationFrame(function () {\n          return _this5._applyLayoutInfos();\n        });\n      });\n      return hasLayoutUpdates;\n    }\n  }, {\n    key: \"afterRender\",\n    value: function afterRender() {\n      if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n  }, {\n    key: \"_flushVisibleViews\",\n    value: function _flushVisibleViews() {\n      var _this6 = this;\n\n      // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n      // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n      // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n      // method to build the final tree.\n      var viewsByParentKey = new Map([[null, []]]);\n\n      var _iterator13 = _createForOfIteratorHelper(this._children),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var view1 = _step13.value;\n          if (!viewsByParentKey.has(view1.layoutInfo.parentKey)) viewsByParentKey.set(view1.layoutInfo.parentKey, []);\n          viewsByParentKey.get(view1.layoutInfo.parentKey).push(view1);\n          if (!viewsByParentKey.has(view1.layoutInfo.key)) viewsByParentKey.set(view1.layoutInfo.key, []);\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var buildTree = function buildTree(parent, views) {\n        return views.map(function (view) {\n          var children = viewsByParentKey.get(view.layoutInfo.key);\n          return _this6.delegate.renderWrapper(parent, view, children, function (childViews) {\n            return buildTree(view, childViews);\n          });\n        });\n      };\n\n      var children1 = buildTree(null, viewsByParentKey.get(null));\n      this.delegate.setVisibleViews(children1);\n    }\n  }, {\n    key: \"_applyLayoutInfo\",\n    value: function _applyLayoutInfo(view, layoutInfo) {\n      if (view.layoutInfo === layoutInfo) return false;\n      view.layoutInfo = layoutInfo;\n      return true;\n    }\n  }, {\n    key: \"_applyLayoutInfos\",\n    value: function _applyLayoutInfos() {\n      var updated = false; // Apply layout infos to visible views\n\n      var _iterator14 = _createForOfIteratorHelper(this._visibleViews.values()),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _view4 = _step14.value;\n          var _cur2 = _view4.layoutInfo;\n\n          if (_cur2) {\n            var _layoutInfo3 = this.layout.getLayoutInfo(_cur2.key);\n\n            if (this._applyLayoutInfo(_view4, _layoutInfo3)) updated = true;\n          }\n        } // Apply final layout infos for views that will be removed\n\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      if (this._transaction) {\n        var _iterator15 = _createForOfIteratorHelper(this._transaction.toRemove.values()),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var view = _step15.value;\n            var cur = view.layoutInfo;\n            var layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n          }\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n\n        var _iterator16 = _createForOfIteratorHelper(this._transaction.removed.values()),\n            _step16;\n\n        try {\n          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n            var view2 = _step16.value;\n            var _cur = view2.layoutInfo;\n\n            var _layoutInfo2 = this._transaction.finalLayoutInfo.get(_cur.key) || _cur;\n\n            _layoutInfo2 = this.layout.getFinalLayoutInfo(_layoutInfo2.copy());\n            if (this._applyLayoutInfo(view2, _layoutInfo2)) updated = true;\n          }\n        } catch (err) {\n          _iterator16.e(err);\n        } finally {\n          _iterator16.f();\n        }\n      }\n\n      if (updated) this._flushVisibleViews();\n    }\n  }, {\n    key: \"_hasLayoutUpdates\",\n    value: function _hasLayoutUpdates() {\n      if (!this._transaction) return false;\n\n      var _iterator17 = _createForOfIteratorHelper(this._visibleViews.values()),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var view = _step17.value;\n          var cur = view.layoutInfo;\n          if (!cur) return true;\n          var layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if ( // Uses equals rather than pointEquals so that width/height changes are taken into account\n          !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"reuseView\",\n    value: function reuseView(view) {\n      view.prepareForReuse();\n\n      this._reusableViews[view.viewType].push(view);\n    }\n  }, {\n    key: \"removeViews\",\n    value: function removeViews(toRemove) {\n      var _iterator18 = _createForOfIteratorHelper(toRemove),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var view = _step18.value;\n\n          this._children.delete(view);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n    }\n  }, {\n    key: \"updateItemSize\",\n    value: function updateItemSize(key, size) {\n      // TODO: we should be able to invalidate a single index path\n      // @ts-ignore\n      if (!this.layout.updateItemSize) return; // If the scroll position is currently animating, add the update\n      // to a queue to be processed after the animation is complete.\n\n      if (this._scrollAnimation) {\n        this._sizeUpdateQueue.set(key, size);\n\n        return;\n      } // @ts-ignore\n\n\n      var changed = this.layout.updateItemSize(key, size);\n      if (changed) this.relayout();\n    }\n  }, {\n    key: \"startScrolling\",\n    value: function startScrolling() {\n      this._isScrolling = true;\n    }\n  }, {\n    key: \"endScrolling\",\n    value: function endScrolling() {\n      this._isScrolling = false;\n\n      this._correctItemOrder();\n\n      this._flushVisibleViews();\n    }\n  }, {\n    key: \"_resetAnimatedContentOffset\",\n    value: function _resetAnimatedContentOffset() {\n      // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n      if (!this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset = new $3041db3296945e6e$export$baf26146a414f24a(0, 0);\n\n        this._applyLayoutInfos();\n      }\n    }\n    /**\n    * Scrolls the item with the given key into view, optionally with an animation.\n    * @param key The key of the item to scroll into view.\n    * @param duration The duration of the scroll animation.\n    */\n\n  }, {\n    key: \"scrollToItem\",\n    value: function scrollToItem(key, options) {\n      // key can be 0, so check if null or undefined\n      if (key == null) return;\n      var layoutInfo = this.layout.getLayoutInfo(key);\n      if (!layoutInfo) return;\n      var _options$duration = options.duration,\n          duration = _options$duration === void 0 ? 300 : _options$duration,\n          _options$shouldScroll = options.shouldScrollX,\n          shouldScrollX = _options$shouldScroll === void 0 ? true : _options$shouldScroll,\n          _options$shouldScroll2 = options.shouldScrollY,\n          shouldScrollY = _options$shouldScroll2 === void 0 ? true : _options$shouldScroll2,\n          _options$offsetX = options.offsetX,\n          offsetX = _options$offsetX === void 0 ? 0 : _options$offsetX,\n          _options$offsetY = options.offsetY,\n          offsetY = _options$offsetY === void 0 ? 0 : _options$offsetY;\n      var x = this.visibleRect.x;\n      var y = this.visibleRect.y;\n      var minX = layoutInfo.rect.x - offsetX;\n      var minY = layoutInfo.rect.y - offsetY;\n      var maxX = x + this.visibleRect.width;\n      var maxY = y + this.visibleRect.height;\n\n      if (shouldScrollX) {\n        if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n      }\n\n      if (shouldScrollY) {\n        if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n      }\n\n      return this.scrollTo(new $3041db3296945e6e$export$baf26146a414f24a(x, y), duration);\n    }\n    /**\n    * Performs an animated scroll to the given offset.\n    * @param offset - The offset to scroll to.\n    * @param duration The duration of the animation.\n    * @returns A promise that resolves when the animation is complete.\n    */\n\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(offset1) {\n      var _this7 = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n\n      // Cancel the current scroll animation\n      if (this._scrollAnimation) {\n        this._scrollAnimation.cancel();\n\n        this._scrollAnimation = null;\n      } // Set the content offset synchronously if the duration is zero\n\n\n      if (duration <= 0 || this.visibleRect.pointEquals(offset1)) {\n        this._setContentOffset(offset1);\n\n        return Promise.resolve();\n      }\n\n      this.startScrolling();\n      this._scrollAnimation = $3eb131dcf37ad5f8$export$dc0b63720788090c(this.visibleRect, offset1, duration, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, function (offset) {\n        _this7._setContentOffset(offset);\n      });\n\n      this._scrollAnimation.then(function () {\n        _this7._scrollAnimation = null; // Process view size updates that occurred during the animation.\n        // Only views that are still visible will be actually updated.\n\n        var _iterator19 = _createForOfIteratorHelper(_this7._sizeUpdateQueue),\n            _step19;\n\n        try {\n          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n            var _step19$value = _slicedToArray(_step19.value, 2),\n                key = _step19$value[0],\n                size = _step19$value[1];\n\n            _this7.updateItemSize(key, size);\n          }\n        } catch (err) {\n          _iterator19.e(err);\n        } finally {\n          _iterator19.f();\n        }\n\n        _this7._sizeUpdateQueue.clear();\n\n        _this7.relayout();\n\n        _this7._processTransactionQueue();\n\n        _this7.endScrolling();\n      });\n\n      return this._scrollAnimation;\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(action, animated) {\n      this._startTransaction();\n\n      if (this._nextTransaction) this._nextTransaction.actions.push(action);\n\n      this._endTransaction(animated);\n    }\n  }, {\n    key: \"_startTransaction\",\n    value: function _startTransaction() {\n      if (!this._nextTransaction) this._nextTransaction = new $8e135e531d8dcb66$export$febc5573c75cefb0();\n      this._nextTransaction.level++;\n    }\n  }, {\n    key: \"_endTransaction\",\n    value: function _endTransaction(animated) {\n      if (!this._nextTransaction) return false; // Save whether the transaction should be animated.\n\n      if (animated != null) this._nextTransaction.animated = animated; // If we haven't reached level 0, we are still in a\n      // nested transaction. Wait for the parent to end.\n\n      if (--this._nextTransaction.level > 0) return false; // Do nothing for empty transactions\n\n      if (this._nextTransaction.actions.length === 0) {\n        this._nextTransaction = null;\n        return false;\n      } // Default animations to true\n\n\n      if (this._nextTransaction.animated == null) this._nextTransaction.animated = true; // Enqueue the transaction\n\n      this._transactionQueue.push(this._nextTransaction);\n\n      this._nextTransaction = null;\n\n      this._processTransactionQueue();\n\n      return true;\n    }\n  }, {\n    key: \"_processTransactionQueue\",\n    value: function _processTransactionQueue() {\n      // If the current transaction is animating, wait until the end\n      // to process the next transaction.\n      if (this._transaction || this._scrollAnimation) return;\n\n      var next = this._transactionQueue.shift();\n\n      if (next) this._performTransaction(next);\n    }\n  }, {\n    key: \"_getContentRect\",\n    value: function _getContentRect() {\n      return new $60423f92c7f9ad87$export$c79fc6492f3af13d(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n  }, {\n    key: \"_performTransaction\",\n    value: function _performTransaction(transaction) {\n      var _this8 = this;\n\n      this._transaction = transaction;\n      this.relayoutNow({\n        transaction: transaction,\n        animated: transaction.animated,\n        beforeLayout: function beforeLayout() {\n          // Get the initial layout infos for all views before the updates\n          // so we can figure out which views to add and remove.\n          if (transaction.animated) transaction.initialMap = _this8._getLayoutInfoMap(_this8._getContentRect(), true); // Apply the actions that occurred during this transaction\n\n          var _iterator20 = _createForOfIteratorHelper(transaction.actions),\n              _step20;\n\n          try {\n            for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n              var action = _step20.value;\n              action();\n            }\n          } catch (err) {\n            _iterator20.e(err);\n          } finally {\n            _iterator20.f();\n          }\n        },\n        afterLayout: function afterLayout() {\n          // Get the final layout infos after the updates\n          if (transaction.animated) {\n            transaction.finalMap = _this8._getLayoutInfoMap(_this8._getContentRect());\n\n            _this8._setupTransactionAnimations(transaction);\n          } else _this8._transaction = null;\n        },\n        afterAnimation: function afterAnimation() {\n          // Remove and reuse views when animations are done\n          if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n            var _iterator21 = _createForOfIteratorHelper($fc36f9a046a9ce79$export$cfc14088dfefce5f(transaction.toRemove.values(), transaction.removed.values())),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var view = _step21.value;\n\n                _this8._children.delete(view);\n\n                _this8.reuseView(view);\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n\n          _this8._transaction = null; // Ensure DOM order is correct for accessibility after animations are complete\n\n          _this8._correctItemOrder();\n\n          _this8._flushVisibleViews();\n\n          _this8._processTransactionQueue();\n        }\n      });\n    }\n  }, {\n    key: \"_setupTransactionAnimations\",\n    value: function _setupTransactionAnimations(transaction) {\n      var initialMap = transaction.initialMap,\n          finalMap = transaction.finalMap; // Store initial and final layout infos for animations\n\n      var _iterator22 = _createForOfIteratorHelper(initialMap),\n          _step22;\n\n      try {\n        for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n          var _step22$value = _slicedToArray(_step22.value, 2),\n              key = _step22$value[0],\n              layoutInfo = _step22$value[1];\n\n          if (finalMap.has(key)) // Store the initial layout info for use during animations.\n            transaction.initialLayoutInfo.set(key, layoutInfo);else // This view was removed. Store the layout info for use\n            // in Layout#getFinalLayoutInfo during animations.\n            transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        } // Get initial layout infos for views that were added\n\n      } catch (err) {\n        _iterator22.e(err);\n      } finally {\n        _iterator22.f();\n      }\n\n      var _iterator23 = _createForOfIteratorHelper(finalMap),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var _step23$value = _slicedToArray(_step23.value, 2),\n              key3 = _step23$value[0],\n              layoutInfo1 = _step23$value[1];\n\n          if (!initialMap.has(key3)) {\n            var initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo1.copy());\n            transaction.initialLayoutInfo.set(key3, initialLayoutInfo);\n          }\n        } // Figure out which views were removed.\n\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      var _iterator24 = _createForOfIteratorHelper(this._visibleViews),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        {\n          var _step24$value = _slicedToArray(_step24.value, 2),\n              key4 = _step24$value[0],\n              view = _step24$value[1];\n\n          if (!finalMap.has(key4) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key4, view);\n\n            this._visibleViews.delete(key4); // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n\n\n            if (view.layoutInfo) {\n              if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n  }]);\n\n  return $38b9490c1cca8fc4$export$89be5a243e59c4b2;\n}();\n\nfunction $fc0b13b484ac1194$export$1505db82fe357e65(opts) {\n  var _$8D3nr$useState = $8D3nr$useState([]),\n      _$8D3nr$useState2 = _slicedToArray(_$8D3nr$useState, 2),\n      visibleViews = _$8D3nr$useState2[0],\n      setVisibleViews = _$8D3nr$useState2[1];\n\n  var _$8D3nr$useState3 = $8D3nr$useState(new $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec()),\n      _$8D3nr$useState4 = _slicedToArray(_$8D3nr$useState3, 2),\n      contentSize = _$8D3nr$useState4[0],\n      setContentSize = _$8D3nr$useState4[1];\n\n  var _$8D3nr$useState5 = $8D3nr$useState(false),\n      _$8D3nr$useState6 = _slicedToArray(_$8D3nr$useState5, 2),\n      isAnimating = _$8D3nr$useState6[0],\n      setAnimating = _$8D3nr$useState6[1];\n\n  var _$8D3nr$useState7 = $8D3nr$useState(false),\n      _$8D3nr$useState8 = _slicedToArray(_$8D3nr$useState7, 2),\n      isScrolling = _$8D3nr$useState8[0],\n      setScrolling = _$8D3nr$useState8[1];\n\n  var virtualizer = $8D3nr$useMemo(function () {\n    return new $38b9490c1cca8fc4$export$89be5a243e59c4b2();\n  }, []);\n  virtualizer.delegate = {\n    setVisibleViews: setVisibleViews,\n    setVisibleRect: function setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize: setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: function beginAnimations() {\n      return setAnimating(true);\n    },\n    endAnimations: function endAnimations() {\n      return setAnimating(false);\n    },\n    getScrollAnchor: opts.getScrollAnchor\n  };\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n  $8D3nr$useLayoutEffect(function () {\n    virtualizer.afterRender();\n  }); // eslint-disable-next-line arrow-body-style\n\n  $8D3nr$useEffect(function () {\n    return function () {\n      return virtualizer.willUnmount();\n    };\n  }, []);\n  return {\n    virtualizer: virtualizer,\n    visibleViews: visibleViews,\n    setVisibleRect: $8D3nr$useCallback(function (rect) {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize: contentSize,\n    isAnimating: isAnimating,\n    isScrolling: isScrolling,\n    startScrolling: $8D3nr$useCallback(function () {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: $8D3nr$useCallback(function () {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n\nexport { $c74cda7d31af1253$export$c84671f46d6a1ca as Layout, $d7fd61009c21d0bb$export$7e0eeb9da702a085 as LayoutInfo, $3041db3296945e6e$export$baf26146a414f24a as Point, $60423f92c7f9ad87$export$c79fc6492f3af13d as Rect, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec as Size, $ad1d98aa8f0c31b4$export$1a5223887c560441 as ReusableView, $fc0b13b484ac1194$export$1505db82fe357e65 as useVirtualizerState };","map":{"version":3,"mappings":"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","names":["$fc36f9a046a9ce79$export$cfc14088dfefce5f","$c74cda7d31af1253$export$c84671f46d6a1ca","newRect","oldRect","width","height","invalidationContext","layoutInfo","$d7fd61009c21d0bb$export$7e0eeb9da702a085","type","key","rect","parentKey","estimatedSize","isSticky","opacity","transform","zIndex","allowOverflow","res","copy","$3041db3296945e6e$export$baf26146a414f24a","x","y","point","$60423f92c7f9ad87$export$c79fc6492f3af13d","maxX","maxY","containsPoint","size","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","other","$ad1d98aa8f0c31b4$var$KEY","$ad1d98aa8f0c31b4$export$1a5223887c560441","virtualizer","content","rendered","$3eb131dcf37ad5f8$var$perf","window","performance","$3eb131dcf37ad5f8$var$perfNow","now","webkitNow","msNow","mozNow","$3eb131dcf37ad5f8$var$getTime","bind","Date","getTime","$3eb131dcf37ad5f8$var$fixTs","$3eb131dcf37ad5f8$export$dc0b63720788090c","begin","end","duration","ease","fn","canceled","raf_id","promise","Promise","resolve","start","diffX","diffY","requestAnimationFrame","run","t","delta","proceed","cancel","cancelAnimationFrame","$3eb131dcf37ad5f8$export$77860c106b4a6a2e","$3eb131dcf37ad5f8$export$57636bb43b1ccbb0","Math","sin","PI","$fc36f9a046a9ce79$export$37a26b283fd7740e","a","b","Set","keys","has","add","$fc36f9a046a9ce79$export$acaf96a27438246b","toRemove","toAdd","toUpdate","iterators","iterator","$fc36f9a046a9ce79$export$6897c284b6f9f4dc","object","$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64","$364191b3decf3697$var$RollingAverage","count","value","sample","$364191b3decf3697$export$4455ee6afb38dcbb","startTime","averagePerf","averageTime","velocity","overscanX","overscanY","visibleRect","time","addSample","o","abs","overscanned","round","min","$8e135e531d8dcb66$export$febc5573c75cefb0","level","actions","animated","initialMap","Map","finalMap","initialLayoutInfo","finalLayoutInfo","removed","$38b9490c1cca8fc4$export$89be5a243e59c4b2","options","_contentSize","_visibleRect","_reusableViews","_visibleLayoutInfos","_visibleViews","_renderedContent","WeakMap","_children","_invalidationContext","_overscanManager","_persistedKeys","_scrollAnimation","_isScrolling","_sizeUpdateQueue","_animatedContentOffset","_transaction","_nextTransaction","_transactionQueue","_transitionDuration","transitionDuration","anchorScrollPosition","anchorScrollPositionAtTop","shouldOverscan","delegate","setContentSize","offset","setVisibleRect","_setVisibleRect","forceUpdate","current","equals","shouldInvalidate","layout","_resetAnimatedContentOffset","relayout","offsetChanged","pointEquals","sizeChanged","sizeEquals","updateSubviews","_collection","data","_setData","_runTransaction","reloadData","contentChanged","getItem","persistedKeys","k","getLayoutInfo","_layout","setLayout","applyLayout","getType","reuseType","_getReuseType","reusable","view","length","pop","viewType","isOrigin","_renderView","reusableView","_renderContent","cached","get","renderView","set","Array","from","values","visibleViews","filter","v","layoutInfos","getVisibleLayoutInfos","intersects","_relayoutRaf","context","Object","assign","relayoutNow","scrollAnchor","_getScrollAnchor","beforeLayout","validate","_setContentSize","getContentSize","afterLayout","getVisibleRect","restoredScrollAnchor","_restoreScrollAnchor","contentOffsetX","contentOffsetY","max","contentSize","hasLayoutUpdates","_setContentOffset","transaction","_applyLayoutInfos","_enableTransitions","done","_disableTransitions","afterAnimation","setTimeout","delete","beginAnimations","endAnimations","getScrollAnchor","corner","getCornerInRect","cornerAnchor","area","contentOffset","ref","finalAnchor","adjustment","getOverscannedRect","_getLayoutInfoMap","map","visibleLayoutInfos","currentlyVisible","item","reuseView","key1","_applyLayoutInfo","getReusableView","key2","removeViews","_correctItemOrder","_flushVisibleViews","_hasLayoutUpdates","collectMetrics","viewsByParentKey","view1","push","buildTree","parent","views","children","renderWrapper","childViews","children1","setVisibleViews","updated","cur","view2","getFinalLayoutInfo","prepareForReuse","updateItemSize","changed","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","scrollTo","offset1","startScrolling","then","clear","_processTransactionQueue","endScrolling","action","_startTransaction","_endTransaction","next","shift","_performTransaction","_getContentRect","_setupTransactionAnimations","key3","layoutInfo1","getInitialLayoutInfo","key4","$fc0b13b484ac1194$export$1505db82fe357e65","opts","$8D3nr$useState","isAnimating","setAnimating","isScrolling","setScrolling","$8D3nr$useMemo","onVisibleRectChange","collection","$8D3nr$useLayoutEffect","afterRender","$8D3nr$useEffect","willUnmount","$8D3nr$useCallback"],"sources":["/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/utils.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Layout.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/LayoutInfo.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Point.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Rect.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Size.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/ReusableView.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/tween.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/OverscanManager.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Transaction.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/Virtualizer.ts","/Users/tomasmonge/Desktop/proyecto Estadistica/node_modules/@react-stately/virtualizer/dist/packages/@react-stately/virtualizer/src/useVirtualizerState.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport function keyDiff<T>(a: Map<T, any>, b: Map<T, any>): Set<T> {\n  let res = new Set<T>();\n\n  for (let key of a.keys()) {\n    if (!b.has(key)) {\n      res.add(key);\n    }\n  }\n\n  return res;\n}\n\n/**\n * Returns the key difference between two maps. Returns a set of\n * keys to add to and remove from a to make it equal to b.\n * @private\n */\nexport function difference<T>(a: Map<T, any>, b: Map<T, any>) {\n  let toRemove = keyDiff(a, b);\n  let toAdd = keyDiff(b, a);\n  let toUpdate = new Set;\n  for (let key of a.keys()) {\n    if (b.has(key)) {\n      toUpdate.add(key);\n    }\n  }\n  return {toRemove, toAdd, toUpdate};\n}\n\n/**\n * Returns an iterator that yields the items in all of the given iterators.\n * @private\n */\nexport function* concatIterators<T>(...iterators: Iterable<T>[]) {\n  for (let iterator of iterators) {\n    yield* iterator;\n  }\n}\n\n/**\n * Inverts the keys and values of an object.\n * @private\n */\nexport function invert(object) {\n  let res = {};\n  for (let key in object) {\n    res[object[key]] = key;\n  }\n\n  return res;\n}\n\n/** Returns whether two sets are equal. */\nexport function isSetEqual<T>(a: Set<T>, b: Set<T>): boolean {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (let key of a) {\n    if (!b.has(key)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {InvalidationContext} from './types';\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\n// import {Point} from './Point';\nimport {Rect} from './Rect';\nimport {Size} from './Size';\nimport {Virtualizer} from './Virtualizer';\n// import { DragTarget, DropTarget } from '@react-types/shared';\n\n/**\n * [CollectionView]{@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * @see {@link getVisibleLayoutInfos}\n * @see {@link getLayoutInfo}\n */\nexport abstract class Layout<T extends object> {\n  /** The CollectionView the layout is currently attached to. */\n  virtualizer: Virtualizer<T, any, any>;\n\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   */\n  shouldInvalidate(newRect: Rect, oldRect: Rect): boolean {\n    // By default, invalidate when the size changes\n    return newRect.width !== oldRect.width\n        || newRect.height !== oldRect.height;\n  }\n\n  /**\n   * This method allows the layout to perform any pre-computation\n   * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n   * Called by the collection view before {@link getVisibleLayoutInfos}\n   * or {@link getLayoutInfo} are called.\n   */\n  validate(invalidationContext: InvalidationContext<T, any>) {} // eslint-disable-line @typescript-eslint/no-unused-vars\n\n  /**\n   * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n   * Should be implemented by subclasses.\n   * @param rect The rectangle that should contain the returned LayoutInfo objects.\n   */\n  abstract getVisibleLayoutInfos(rect: Rect): LayoutInfo[];\n\n  /**\n   * Returns a {@link LayoutInfo} for the given key.\n   * Should be implemented by subclasses.\n   * @param key The key of the LayoutInfo to retrieve.\n   */\n  abstract getLayoutInfo(key: Key): LayoutInfo;\n\n  /**\n   * Returns size of the content. By default, it returns collectionView's size.\n   */\n  abstract getContentSize(): Size;\n\n  /**\n   * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n   * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n   * @param point The point at which the drag occurred.\n   */\n  // getDragTarget(point: Point): DragTarget | null {\n  //   let target = this.virtualizer.keyAtPoint(point);\n  //   if (!target) {\n  //     return null;\n  //   }\n\n  //   return {\n  //     type: 'item',\n  //     key: target\n  //   };\n  // }\n\n  /**\n   * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n   * to reject the drop. The dropped items will be inserted before the resulting target.\n   * @param point The point at which the drop occurred.\n   */\n  // getDropTarget(point: Point): DropTarget | null {\n  //   return null;\n  // }\n\n  /**\n   * Returns the starting attributes for an animated insertion.\n   * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n   * The default implementation just returns its input.\n   *\n   * @param layoutInfo The proposed LayoutInfo for this view.\n   */\n  getInitialLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n\n  /**\n   * Returns the ending attributes for an animated removal.\n   * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n   * to the one returned by this method. The default implementation returns its input.\n   *\n   * @param layoutInfo The original LayoutInfo for this view.\n   */\n  getFinalLayoutInfo(layoutInfo: LayoutInfo): LayoutInfo {\n    return layoutInfo;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {Rect} from './Rect';\n\n/**\n * Instances of this lightweight class are created by {@link Layout} subclasses\n * to represent each view in the {@link CollectionView}. LayoutInfo objects describe\n * various properties of a view, such as its position and size, and style information.\n * The collection view uses this information when creating actual views to display.\n */\nexport class LayoutInfo {\n  /**\n   * A string representing the view type. Should be `'item'` for item views.\n   * Other types are used by supplementary views.\n   */\n  type: string;\n\n  /**\n   * A unique key for this view. For item views, it should match the content key.\n   */\n  key: Key;\n\n  /**\n   * The key for a parent layout info, if any.\n   */\n  parentKey: Key | null;\n\n  /**\n   * The rectangle describing the size and position of this view.\n   */\n  rect: Rect;\n\n  /**\n   * Whether the size is estimated. `false` by default.\n   */\n  estimatedSize: boolean;\n\n  /**\n   * Whether the layout info sticks to the viewport when scrolling.\n   */\n  isSticky: boolean;\n\n  /**\n   * The view's opacity. 1 by default.\n   */\n  opacity: number;\n\n  /**\n   * A CSS transform string to apply to the view. `null` by default.\n   */\n  transform: string | null;\n\n  /**\n   * The z-index of the view. 0 by default.\n   */\n  zIndex: number;\n\n  /**\n   * Whether the layout info allows its contents to overflow its container.\n   * @default false\n   */\n  allowOverflow: boolean;\n\n  /**\n   * @param type A string representing the view type. Should be `'item'` for item views.\n                            Other types are used by supplementary views.\n   * @param key The unique key for this view.\n   * @param rect The rectangle describing the size and position of this view.\n   */\n  constructor(type: string, key: Key, rect: Rect) {\n    this.type = type;\n    this.key = key;\n    this.parentKey = null;\n    this.rect = rect;\n    this.estimatedSize = false;\n    this.isSticky = false;\n    this.opacity = 1;\n    this.transform = null;\n    this.zIndex = 0;\n    this.allowOverflow = false;\n  }\n\n  /**\n   * Returns a copy of the LayoutInfo.\n   */\n  copy(): LayoutInfo {\n    let res = new LayoutInfo(this.type, this.key, this.rect.copy());\n    res.estimatedSize = this.estimatedSize;\n    res.opacity = this.opacity;\n    res.transform = this.transform;\n    res.parentKey = this.parentKey;\n    res.isSticky = this.isSticky;\n    res.zIndex = this.zIndex;\n    res.allowOverflow = this.allowOverflow;\n    return res;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Point {\n  /** The x-coordinate of the point. */\n  x: number;\n\n  /** The y-coordinate of the point. */\n  y: number;\n\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  /**\n   * Returns a copy of this point.\n   */\n  copy(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * Checks if two points are equal.\n   */\n  equals(point: Point): boolean {\n    return this.x === point.x && this.y === point.y;\n  }\n\n  /**\n   * Returns true if this point is the origin.\n   */\n  isOrigin(): boolean {\n    return this.x === 0 && this.y === 0;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Size} from './Size';\n\nexport type RectCorner = 'topLeft' | 'topRight' | 'bottomLeft' | 'bottomRight';\n\n/**\n * Represents a rectangle.\n */\nexport class Rect {\n  /** The x-coordinate of the rectangle. */\n  x: number;\n\n  /** The y-coordinate of the rectangle. */\n  y: number;\n\n  /** The width of the rectangle. */\n  width: number;\n\n  /** The height of the rectangle. */\n  height: number;\n\n  constructor(x = 0, y = 0, width = 0, height = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * The maximum x-coordinate in the rectangle.\n   */\n  get maxX(): number {\n    return this.x + this.width;\n  }\n\n  /**\n   * The maximum y-coordinate in the rectangle.\n   */\n  get maxY(): number {\n    return this.y + this.height;\n  }\n\n  /**\n   * The area of the rectangle.\n   */\n  get area(): number {\n    return this.width * this.height;\n  }\n\n  /**\n   * The top left corner of the rectangle.\n   */\n  get topLeft(): Point {\n    return new Point(this.x, this.y);\n  }\n\n  /**\n   * The top right corner of the rectangle.\n   */\n  get topRight(): Point {\n    return new Point(this.maxX, this.y);\n  }\n\n  /**\n   * The bottom left corner of the rectangle.\n   */\n  get bottomLeft(): Point {\n    return new Point(this.x, this.maxY);\n  }\n\n  /**\n   * The bottom right corner of the rectangle.\n   */\n  get bottomRight(): Point {\n    return new Point(this.maxX, this.maxY);\n  }\n\n  /**\n   * Returns whether this rectangle intersects another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  intersects(rect: Rect): boolean {\n    return this.x <= rect.x + rect.width\n        && rect.x <= this.x + this.width\n        && this.y <= rect.y + rect.height\n        && rect.y <= this.y + this.height;\n  }\n\n  /**\n   * Returns whether this rectangle fully contains another rectangle.\n   * @param rect - The rectangle to check.\n   */\n  containsRect(rect: Rect): boolean {\n    return this.x <= rect.x\n        && this.y <= rect.y\n        && this.maxX >= rect.maxX\n        && this.maxY >= rect.maxY;\n  }\n\n  /**\n   * Returns whether the rectangle contains the given point.\n   * @param point - The point to check.\n   */\n  containsPoint(point: Point): boolean {\n    return this.x <= point.x\n        && this.y <= point.y\n        && this.maxX >= point.x\n        && this.maxY >= point.y;\n  }\n\n  /**\n   * Returns the first corner of this rectangle (from top to bottom, left to right)\n   * that is contained in the given rectangle, or null of the rectangles do not intersect.\n   * @param rect - The rectangle to check.\n   */\n  getCornerInRect(rect: Rect): RectCorner | null {\n    for (let key of ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']) {\n      if (rect.containsPoint(this[key])) {\n        return key as RectCorner;\n      }\n    }\n\n    return null;\n  }\n\n  equals(rect: Rect) {\n    return rect.x === this.x\n        && rect.y === this.y\n        && rect.width === this.width\n        && rect.height === this.height;\n  }\n\n  pointEquals(point: Point | Rect) {\n    return this.x === point.x\n        && this.y === point.y;\n  }\n\n  sizeEquals(size: Size | Rect) {\n    return this.width === size.width\n        && this.height === size.height;\n  }\n\n  /**\n   * Returns a copy of this rectangle.\n   */\n  copy(): Rect {\n    return new Rect(this.x, this.y, this.width, this.height);\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nexport class Size {\n  width: number;\n  height: number;\n\n  constructor(width = 0, height = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Returns a copy of this size.\n   */\n  copy(): Size {\n    return new Size(this.width, this.height);\n  }\n\n  /**\n   * Returns whether this size is equal to another one.\n   */\n  equals(other: Size): boolean {\n    return this.width === other.width\n        && this.height === other.height;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {Virtualizer} from './Virtualizer';\n\nlet KEY = 0;\n\n/**\n * [CollectionView]{@link CollectionView} creates instances of the [ReusableView]{@link ReusableView} class to\n * represent views currently being displayed. ReusableViews manage a DOM node, handle\n * applying {@link LayoutInfo} objects to the view, and render content\n * as needed. Subclasses must implement the {@link render} method at a\n * minimum. Other methods can be overridden to customize behavior.\n */\nexport class ReusableView<T extends object, V> {\n  /** The CollectionVirtualizer this view is a part of. */\n  virtualizer: Virtualizer<T, V, unknown>;\n\n  /** The LayoutInfo this view is currently representing. */\n  layoutInfo: LayoutInfo | null;\n\n  /** The content currently being displayed by this view, set by the collection view. */\n  content: T;\n\n  rendered: V;\n\n  viewType: string;\n  key: Key;\n\n  constructor(virtualizer: Virtualizer<T, V, unknown>) {\n    this.virtualizer = virtualizer;\n    this.key = ++KEY;\n  }\n\n  /**\n   * Prepares the view for reuse. Called just before the view is removed from the DOM.\n   */\n  prepareForReuse() {\n    this.content = null;\n    this.rendered = null;\n    this.layoutInfo = null;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\n\n// use high res timer if available\nlet perf = typeof window !== 'undefined' ? window.performance : null;\n// @ts-ignore\nlet perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow);\nlet getTime = perfNow ? perfNow.bind(perf) : function () {\n  return Date.now ? Date.now() : new Date().getTime();\n};\n\nlet fixTs: boolean;\n\nexport interface CancelablePromise<T> extends Promise<T> {\n  cancel(): void\n}\n\nexport function tween(begin, end, duration, ease, fn): CancelablePromise<void> {\n  let canceled = false;\n  let raf_id: number;\n\n  let promise = new Promise(resolve => {\n    let start = getTime();\n    let diffX = end.x - begin.x;\n    let diffY = end.y - begin.y;\n\n    raf_id = requestAnimationFrame(function run(t) {\n      // if we're using a high res timer, make sure timestamp is not the old epoch-based value.\n      // http://updates.html5rocks.com/2012/05/requestAnimationFrame-API-now-with-sub-millisecond-precision\n      if (fixTs == null) {\n        fixTs = t > 1e12 !== getTime() > 1e12;\n      }\n\n      if (fixTs) {\n        t = getTime();\n      }\n\n      // check if we're done\n      let delta = t - start;\n      if (delta > duration) {\n        fn(end);\n        resolve();\n      } else {\n        // call frame callback after computing eased time and get the next frame\n        let proceed = fn(new Point(\n          begin.x + diffX * ease(delta / duration),\n          begin.y + diffY * ease(delta / duration)\n        ));\n\n        if (proceed !== false && !canceled) {\n          raf_id = requestAnimationFrame(run);\n        }\n      }\n    });\n  }) as CancelablePromise<void>;\n\n  promise.cancel = function () {\n    canceled = true;\n    cancelAnimationFrame(raf_id);\n  };\n\n  return promise;\n}\n\n// easing functions\nexport function linearEasing(t) {\n  return t;\n}\n\nexport function easeOut(t) {\n  return Math.sin(t * Math.PI / 2);\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Point} from './Point';\nimport {Rect} from './Rect';\n\nclass RollingAverage {\n  private count: number = 0;\n  value: number = 0;\n  \n  addSample(sample: number) {\n    this.count++;\n    this.value += (sample - this.value) / this.count;\n  }\n}\n\nexport class OverscanManager {\n  private startTime = 0;\n  private averagePerf = new RollingAverage();\n  private averageTime = new RollingAverage();\n  private velocity = new Point(5, 5);\n  private overscanX = new RollingAverage();\n  private overscanY = new RollingAverage();\n  private visibleRect = new Rect();\n  \n  setVisibleRect(rect: Rect) {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averageTime.addSample(time);\n\n      if (rect.x !== this.visibleRect.x && time > 0) {\n        this.velocity.x = (rect.x - this.visibleRect.x) / time;\n      }\n\n      if (rect.y !== this.visibleRect.y && time > 0) {\n        this.velocity.y = (rect.y - this.visibleRect.y) / time;\n      }\n    }\n\n    this.startTime = performance.now();\n    this.visibleRect = rect;\n  }\n\n  collectMetrics() {\n    let time = performance.now() - this.startTime;\n    if (time < 500) {\n      this.averagePerf.addSample(time);\n    }\n\n    if (this.visibleRect.height > 0) {\n      let o = Math.abs(this.velocity.y * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanY.addSample(o);\n    }\n\n    if (this.visibleRect.width > 0) {\n      let o = Math.abs(this.velocity.x * (this.averageTime.value + this.averagePerf.value));  \n      this.overscanX.addSample(o);\n    }\n  }\n\n  getOverscannedRect() {\n    let overscanned = this.visibleRect.copy();\n\n    let overscanY = Math.round(Math.min(this.visibleRect.height * 2, this.overscanY.value) / 100) * 100;\n    if (this.velocity.y > 0) {\n      overscanned.y -= overscanY * 0.2;\n      overscanned.height += overscanY + overscanY * 0.2;\n    } else {\n      overscanned.y -= overscanY;\n      overscanned.height += overscanY + overscanY * 0.2;\n    }\n\n    let overscanX = Math.round(Math.min(this.visibleRect.width * 2, this.overscanX.value) / 100) * 100;\n    if (this.velocity.x > 0) {\n      overscanned.x -= overscanX * 0.2;\n      overscanned.width += overscanX + overscanX * 0.2;\n    } else {\n      overscanned.x -= overscanX;\n      overscanned.width += overscanX + overscanX * 0.2;\n    }\n\n    return overscanned;\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Key} from 'react';\nimport {LayoutInfo} from './LayoutInfo';\nimport {ReusableView} from './ReusableView';\n\ntype LayoutInfoMap = Map<Key, LayoutInfo>;\nexport class Transaction<T extends object, V> {\n  level = 0;\n  actions: (() => void)[] = [];\n  animated = true;\n  initialMap: LayoutInfoMap = new Map();\n  finalMap: LayoutInfoMap = new Map();\n  initialLayoutInfo: LayoutInfoMap = new Map();\n  finalLayoutInfo: LayoutInfoMap = new Map();\n  removed: Map<Key, ReusableView<T, V>> = new Map();\n  toRemove: Map<Key, ReusableView<T, V>> = new Map();\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {CancelablePromise, easeOut, tween} from './tween';\nimport {Collection} from '@react-types/shared';\nimport {concatIterators, difference, isSetEqual} from './utils';\nimport {\n  InvalidationContext,\n  ScrollAnchor,\n  ScrollToItemOptions,\n  VirtualizerDelegate,\n  VirtualizerOptions\n} from './types';\nimport {Key} from 'react';\nimport {Layout} from './Layout';\nimport {LayoutInfo} from './LayoutInfo';\nimport {OverscanManager} from './OverscanManager';\nimport {Point} from './Point';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {Transaction} from './Transaction';\n\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\nexport class Virtualizer<T extends object, V, W> {\n  /**\n   * The collection view delegate. The delegate is used by the collection view\n   * to create and configure views.\n   */\n  delegate: VirtualizerDelegate<T, V, W>;\n\n  /** The duration of animated layout changes, in milliseconds. Default is 500ms. */\n  transitionDuration: number;\n\n  /**\n   * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n   * after layout changes outside the viewport. Default is off.\n   */\n  anchorScrollPosition: boolean;\n\n  /** Whether to anchor the scroll position when at the top of the content. Default is off. */\n  anchorScrollPositionAtTop: boolean;\n\n  /**\n   * Whether to overscan the visible area to pre-render items slightly outside and\n   * improve performance. Default is on.\n   */\n  shouldOverscan: boolean;\n\n  private _collection: Collection<T>;\n  private _layout: Layout<T>;\n  private _contentSize: Size;\n  private _visibleRect: Rect;\n  private _visibleLayoutInfos: Map<Key, LayoutInfo>;\n  private _reusableViews: {[type: string]: ReusableView<T, V>[]};\n  private _visibleViews: Map<Key, ReusableView<T, V>>;\n  private _renderedContent: WeakMap<T, V>;\n  private _children: Set<ReusableView<T, V>>;\n  private _invalidationContext: InvalidationContext<T, V> | null;\n  private _overscanManager: OverscanManager;\n  private _persistedKeys: Set<Key>;\n  private _relayoutRaf: number | null;\n  private _scrollAnimation: CancelablePromise<void> | null;\n  private _isScrolling: boolean;\n  private _sizeUpdateQueue: Map<Key, Size>;\n  private _animatedContentOffset: Point;\n  private _transaction: Transaction<T, V> | null;\n  private _nextTransaction: Transaction<T, V> | null;\n  private _transactionQueue: Transaction<T, V>[];\n\n  constructor(options: VirtualizerOptions<T, V, W> = {}) {\n    this._contentSize = new Size;\n    this._visibleRect = new Rect;\n\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new OverscanManager();\n    this._persistedKeys = new Set();\n\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new Point(0, 0);\n\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n\n    // Set options from passed object if given\n    this.transitionDuration = options.transitionDuration ?? 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of ['delegate', 'size', 'layout', 'collection']) {\n      if (options[key]) {\n        this[key] = options[key];\n      }\n    }\n  }\n\n  _setContentSize(size: Size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n\n  _setContentOffset(offset: Point) {\n    let rect = new Rect(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n\n  /**\n   * Get the size of the scrollable content.\n   */\n  get contentSize(): Size {\n    return this._contentSize;\n  }\n\n  /**\n   * Get the collection view's currently visible rectangle.\n   */\n  get visibleRect(): Rect {\n    return this._visibleRect;\n  }\n\n  /**\n   * Set the collection view's currently visible rectangle.\n   */\n  set visibleRect(rect: Rect) {\n    this._setVisibleRect(rect);\n  }\n\n  _setVisibleRect(rect: Rect, forceUpdate = false) {\n    let current = this._visibleRect;\n\n    // Ignore if the rects are equal\n    if (rect.equals(current)) {\n      return;\n    }\n\n    if (this.shouldOverscan) {\n      this._overscanManager.setVisibleRect(rect);\n    }\n\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n\n    if (shouldInvalidate) {\n      this.relayout({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });\n    } else {\n      this.updateSubviews(forceUpdate);\n    }\n  }\n\n  get collection(): Collection<T> {\n    return this._collection;\n  }\n\n  set collection(data: Collection<T>) {\n    this._setData(data);\n  }\n\n  private _setData(data: Collection<T>) {\n    if (data === this._collection) {\n      return;\n    }\n\n    if (this._collection) {\n      this._runTransaction(() => {\n        this._collection = data;\n      }, this.transitionDuration > 0);\n    } else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n\n  /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n\n  /**\n   * Returns the item with the given key.\n   */\n  getItem(key: Key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys(): Set<Key> {\n    return this._persistedKeys;\n  }\n\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys: Set<Key>) {\n    if (!isSetEqual(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key: Key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) {\n      return true;\n    }\n\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) {\n      while (k != null) {\n        let layoutInfo = this.layout.getLayoutInfo(k);\n        if (!layoutInfo) {\n          break;\n        }\n\n        k = layoutInfo.parentKey;\n\n        if (k === key) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the collection view's layout.\n   */\n  get layout(): Layout<T> {\n    return this._layout;\n  }\n\n  /**\n   * Set the collection view's layout.\n   */\n  set layout(layout: Layout<T>) {\n    this.setLayout(layout);\n  }\n\n  /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */\n  setLayout(layout: Layout<T>, animated = false) {\n    if (layout === this._layout) {\n      return;\n    }\n\n    let applyLayout = () => {\n      if (this._layout) {\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      }\n\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n\n    if (animated) {\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);\n    } else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n\n  private _getReuseType(layoutInfo: LayoutInfo, content: T | null) {\n    if (layoutInfo.type === 'item' && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n      let reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n      return {type, reuseType};\n    }\n\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n\n  getReusableView(layoutInfo: LayoutInfo): ReusableView<T, V> {\n    let content = this.getItem(layoutInfo.key);\n    let {reuseType} = this._getReuseType(layoutInfo, content);\n\n    if (!this._reusableViews[reuseType]) {\n      this._reusableViews[reuseType] = [];\n    }\n\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0\n      ? reusable.pop()\n      : new ReusableView<T, V>(this);\n\n    view.viewType = reuseType;\n\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n\n    view.layoutInfo = layoutInfo;\n\n    this._renderView(view);\n    return view;\n  }\n\n  private _renderView(reusableView: ReusableView<T, V>) {\n    let {type, key} = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n\n  private _renderContent(type: string, content: T) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) {\n      return cached;\n    }\n\n    let rendered = this.delegate.renderView(type, content);\n    if (content) {\n      this._renderedContent.set(content, rendered);\n    }\n    return rendered;\n  }\n\n  /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */\n  get visibleViews(): ReusableView<T, V>[] {\n    return Array.from(this._visibleViews.values());\n  }\n\n  /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */\n  getView(key: Key): ReusableView<T, V> | null {\n    return this._visibleViews.get(key) || null;\n  }\n\n  /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */\n  getViewsOfType(type: string): ReusableView<T, V>[] {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n\n  /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */\n  keyForView(view: ReusableView<T, V>): Key | null {\n    if (view && view.layoutInfo) {\n      return view.layoutInfo.key;\n    }\n\n    return null;\n  }\n\n  /**\n   * Returns the key for the item view currently at the given point.\n   */\n  keyAtPoint(point: Point): Key | null {\n    let rect = new Rect(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) {\n        return layoutInfo.key;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n\n  /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */\n  relayout(context: InvalidationContext<T, V> = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === 'undefined') {\n      return;\n    }\n\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n\n    this._invalidationContext = context;\n    this._relayoutRaf = requestAnimationFrame(() => {\n      this._relayoutRaf = null;\n      this.relayoutNow();\n    });\n  }\n\n  /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */\n  relayoutNow(context: InvalidationContext<T, V> = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {...this._invalidationContext, ...context};\n    }\n\n    // Reset the invalidation context\n    this._invalidationContext = null;\n\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) {\n      return;\n    }\n\n    let scrollAnchor = this._getScrollAnchor();\n\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === 'function') {\n      context.beforeLayout();\n    }\n\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === 'function') {\n      context.afterLayout();\n    }\n\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else {\n        this._setContentOffset(new Point(contentOffsetX, contentOffsetY));\n      }\n    } else {\n      hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    }\n\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) {\n      this._applyLayoutInfos();\n    }\n\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n\n      let done = () => {\n        this._disableTransitions();\n\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {x, y} = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new Point(x, y));\n        }\n\n        if (typeof context.afterAnimation === 'function') {\n          context.afterAnimation();\n        }\n      };\n\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === 'function') {\n      context.afterAnimation();\n    }\n  }\n\n  /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */\n  private _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) {\n      return;\n    }\n\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n\n  private _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n\n  private _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n\n  private _getScrollAnchor(): ScrollAnchor | null {\n    if (!this.anchorScrollPosition) {\n      return null;\n    }\n\n    let visibleRect = this.getVisibleRect();\n\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {key, layoutInfo, corner, offset};\n        }\n      }\n    }\n\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n      return null;\n    }\n\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor: ScrollAnchor | null = null;\n\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || (offset < cornerAnchor.offset)) {\n            cornerAnchor = {key, layoutInfo, corner, offset};\n          }\n        }\n      }\n    }\n\n    return cornerAnchor;\n  }\n\n  private _restoreScrollAnchor(scrollAnchor: ScrollAnchor | null, context: InvalidationContext<T, V>) {\n    let contentOffset = this.getVisibleRect();\n\n    if (scrollAnchor) {\n      let finalAnchor = context.transaction?.animated\n        ? context.transaction.finalMap.get(scrollAnchor.key)\n        : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n\n      if (finalAnchor) {\n        let adjustment = (finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y) - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n\n    return contentOffset;\n  }\n\n  getVisibleRect(): Rect {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new Rect(x, y, v.width, v.height);\n  }\n\n  getVisibleLayoutInfos() {\n    let rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n\n  private _getLayoutInfoMap(rect: Rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map;\n\n    for (let layoutInfo of layoutInfos) {\n      if (copy) {\n        layoutInfo = layoutInfo.copy();\n      }\n\n      map.set(layoutInfo.key, layoutInfo);\n    }\n\n    return map;\n  }\n\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) {\n      return;\n    }\n\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({toAdd, toRemove, toUpdate} = difference(currentlyVisible, visibleLayoutInfos));\n\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) {\n          continue;\n        }\n\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) {\n          toUpdate.delete(key);\n        } else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {reuseType} = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) {\n          this._applyLayoutInfos();\n        }\n\n        return;\n      }\n    }\n\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set<ReusableView<T, V>>();\n\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) {\n          this._transaction.toRemove.set(key, view);\n        } else {\n          this.reuseView(view);\n        }\n      }\n    }\n\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view: ReusableView<T, V> | void;\n\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) {\n          layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        }\n\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) {\n          this._children.add(view);\n        }\n      }\n\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key) as ReusableView<T, V>;\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) {\n      this.removeViews(removed);\n    }\n\n    this._correctItemOrder();\n    this._flushVisibleViews();\n\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) {\n      requestAnimationFrame(() => {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (this._transaction) {\n          requestAnimationFrame(() => this._applyLayoutInfos());\n        }\n      });\n    }\n\n    return hasLayoutUpdates;\n  }\n\n  afterRender() {\n    if (this.shouldOverscan) {\n      this._overscanManager.collectMetrics();\n    }\n  }\n\n  private _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent heirarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this heirarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      if (!viewsByParentKey.has(view.layoutInfo.parentKey)) {\n        viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      }\n\n      viewsByParentKey.get(view.layoutInfo.parentKey).push(view);\n      if (!viewsByParentKey.has(view.layoutInfo.key)) {\n        viewsByParentKey.set(view.layoutInfo.key, []);\n      }\n    }\n\n    let buildTree = (parent: ReusableView<T, V>, views: ReusableView<T, V>[]): W[] => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(\n        parent,\n        view,\n        children,\n        (childViews) => buildTree(view, childViews)\n      );\n    });\n\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n\n  private _applyLayoutInfo(view: ReusableView<T, V>, layoutInfo: LayoutInfo) {\n    if (view.layoutInfo === layoutInfo) {\n      return false;\n    }\n\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n\n  private _applyLayoutInfos() {\n    let updated = false;\n\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (cur) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) {\n          updated = true;\n        }\n      }\n    }\n\n    if (updated) {\n      this._flushVisibleViews();\n    }\n  }\n\n  private _hasLayoutUpdates() {\n    if (!this._transaction) {\n      return false;\n    }\n\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) {\n        return true;\n      }\n\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n        // Uses equals rather than pointEquals so that width/height changes are taken into account\n        !cur.rect.equals(layoutInfo.rect) ||\n        cur.opacity !== layoutInfo.opacity ||\n        cur.transform !== layoutInfo.transform\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reuseView(view: ReusableView<T, V>) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n\n  removeViews(toRemove: Set<ReusableView<T, V>>) {\n    for (let view of toRemove) {\n      this._children.delete(view);\n    }\n  }\n\n  updateItemSize(key: Key, size: Size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) {\n      return;\n    }\n\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) {\n      this.relayout();\n    }\n  }\n\n  startScrolling() {\n    this._isScrolling = true;\n  }\n\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n\n  private _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new Point(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n\n  /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */\n  scrollToItem(key: Key, options?: ScrollToItemOptions) {\n    // key can be 0, so check if null or undefined\n    if (key == null) {\n      return;\n    }\n\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) {\n      return;\n    }\n\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) {\n        x = minX;\n      } else if (layoutInfo.rect.maxX > maxX) {\n        x += layoutInfo.rect.maxX - maxX;\n      }\n    }\n\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) {\n        y = minY;\n      } else if (layoutInfo.rect.maxY > maxY) {\n        y += layoutInfo.rect.maxY - maxY;\n      }\n    }\n\n    return this.scrollTo(new Point(x, y), duration);\n  }\n\n  /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */\n  scrollTo(offset: Point, duration: number = 300): Promise<void> {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n\n    this.startScrolling();\n\n    this._scrollAnimation = tween(this.visibleRect, offset, duration, easeOut, offset => {this._setContentOffset(offset);});\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) {\n        this.updateItemSize(key, size);\n      }\n\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n\n    return this._scrollAnimation;\n  }\n\n  private _runTransaction(action: () => void, animated?: boolean) {\n    this._startTransaction();\n    if (this._nextTransaction) {\n      this._nextTransaction.actions.push(action);\n    }\n    this._endTransaction(animated);\n  }\n\n  private _startTransaction() {\n    if (!this._nextTransaction) {\n      this._nextTransaction = new Transaction;\n    }\n\n    this._nextTransaction.level++;\n  }\n\n  private _endTransaction(animated?: boolean) {\n    if (!this._nextTransaction) {\n      return false;\n    }\n\n    // Save whether the transaction should be animated.\n    if (animated != null) {\n      this._nextTransaction.animated = animated;\n    }\n\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) {\n      return false;\n    }\n\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n\n    // Default animations to true\n    if (this._nextTransaction.animated == null) {\n      this._nextTransaction.animated = true;\n    }\n\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n\n    this._processTransactionQueue();\n    return true;\n  }\n\n  private _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) {\n      return;\n    }\n\n    let next = this._transactionQueue.shift();\n    if (next) {\n      this._performTransaction(next);\n    }\n  }\n\n  private _getContentRect(): Rect {\n    return new Rect(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n\n  private _performTransaction(transaction: Transaction<T, V>) {\n    this._transaction = transaction;\n\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) {\n          transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        }\n\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) {\n          action();\n        }\n      },\n\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else {\n          this._transaction = null;\n        }\n      },\n\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n          for (let view of concatIterators(transaction.toRemove.values(), transaction.removed.values())) {\n            this._children.delete(view);\n            this.reuseView(view);\n          }\n        }\n\n        this._transaction = null;\n\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n\n        this._processTransactionQueue();\n      }\n    });\n  }\n\n  private _setupTransactionAnimations(transaction: Transaction<T, V>) {\n    let {initialMap, finalMap} = transaction;\n\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) {\n      if (finalMap.has(key)) {\n        // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n      } else {\n        // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n      }\n    }\n\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) {\n      if (!initialMap.has(key)) {\n        let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n        transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n      }\n    }\n\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews) {\n      // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n      // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n      // added, removed... etc in a loop.\n      if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n        transaction.removed.set(key, view);\n        this._visibleViews.delete(key);\n\n        // In case something weird happened, where we have a view but no\n        // initial layout info, use the one attached to the view.\n        if (view.layoutInfo) {\n          if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) {\n            transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n          }\n        }\n      }\n    }\n  }\n}\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {Collection} from '@react-types/shared';\nimport {Key, useCallback, useEffect, useMemo, useState} from 'react';\nimport {Layout} from './Layout';\nimport {Rect} from './Rect';\nimport {ReusableView} from './ReusableView';\nimport {Size} from './Size';\nimport {useLayoutEffect} from '@react-aria/utils';\nimport {Virtualizer} from './Virtualizer';\n\ninterface VirtualizerProps<T extends object, V, W> {\n  renderView(type: string, content: T): V,\n  renderWrapper(\n    parent: ReusableView<T, V> | null,\n    reusableView: ReusableView<T, V>,\n    children: ReusableView<T, V>[],\n    renderChildren: (views: ReusableView<T, V>[]) => W[]\n  ): W,\n  layout: Layout<T>,\n  collection: Collection<T>,\n  onVisibleRectChange(rect: Rect): void,\n  getScrollAnchor?(rect: Rect): Key,\n  transitionDuration?: number\n}\n\nexport interface VirtualizerState<T extends object, V, W> {\n  visibleViews: W[],\n  setVisibleRect: (rect: Rect) => void,\n  contentSize: Size,\n  isAnimating: boolean,\n  virtualizer: Virtualizer<T, V, W>,\n  isScrolling: boolean,\n  startScrolling: () => void,\n  endScrolling: () => void\n}\n\nexport function useVirtualizerState<T extends object, V, W>(opts: VirtualizerProps<T, V, W>): VirtualizerState<T, V, W> {\n  let [visibleViews, setVisibleViews] = useState<W[]>([]);\n  let [contentSize, setContentSize] = useState(new Size());\n  let [isAnimating, setAnimating] = useState(false);\n  let [isScrolling, setScrolling] = useState(false);\n  let virtualizer = useMemo(() => new Virtualizer<T, V, W>(), []);\n\n  virtualizer.delegate = {\n    setVisibleViews,\n    setVisibleRect(rect) {\n      virtualizer.visibleRect = rect;\n      opts.onVisibleRectChange(rect);\n    },\n    setContentSize,\n    renderView: opts.renderView,\n    renderWrapper: opts.renderWrapper,\n    beginAnimations: () => setAnimating(true),\n    endAnimations: () => setAnimating(false),\n    getScrollAnchor: opts.getScrollAnchor\n  };\n\n  virtualizer.layout = opts.layout;\n  virtualizer.collection = opts.collection;\n  virtualizer.transitionDuration = opts.transitionDuration;\n\n  useLayoutEffect(() => {\n    virtualizer.afterRender();\n  });\n\n  // eslint-disable-next-line arrow-body-style\n  useEffect(() => {\n    return () => virtualizer.willUnmount();\n  }, []);\n\n  return {\n    virtualizer,\n    visibleViews,\n    setVisibleRect: useCallback((rect) => {\n      virtualizer.visibleRect = rect;\n    }, [virtualizer]),\n    contentSize,\n    isAnimating,\n    isScrolling,\n    startScrolling: useCallback(() => {\n      virtualizer.startScrolling();\n      setScrolling(true);\n    }, [virtualizer]),\n    endScrolling: useCallback(() => {\n      virtualizer.endScrolling();\n      setScrolling(false);\n    }, [virtualizer])\n  };\n}\n"]},"metadata":{},"sourceType":"module"}